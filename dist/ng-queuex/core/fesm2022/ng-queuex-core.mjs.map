{"version":3,"file":"ng-queuex-core.mjs","sources":["../../../../projects/ng-queuex/core/src/scheduler/scheduler_utils.ts","../../../../projects/ng-queuex/core/src/utils.ts","../../../../projects/ng-queuex/core/src/scheduler/scheduler.ts","../../../../projects/ng-queuex/core/src/environment/environment.ts","../../../../projects/ng-queuex/core/src/instructions/instructions.ts","../../../../projects/ng-queuex/core/src/iterable_differs/default_iterable_differ.ts","../../../../projects/ng-queuex/core/src/iterable_differs/iterable_differs.ts","../../../../projects/ng-queuex/core/src/shared_signal/shared_signal.ts","../../../../projects/ng-queuex/core/src/value_ref/value_ref.ts","../../../../projects/ng-queuex/core/src/concurrent_effect/concurrent_effect.ts","../../../../projects/ng-queuex/core/public-api.ts","../../../../projects/ng-queuex/core/ng-queuex-core.ts"],"sourcesContent":["import { computed, isSignal, Signal } from \"@angular/core\";\r\n\r\nexport interface SchedulerTask {\r\n  id: number;\r\n  sortIndex: number;\r\n  callback: VoidFunction | null;\r\n  priorityLevel: Priority;\r\n  startTime: number;\r\n  expirationTime: number;\r\n  zone: ZoneMinApi;\r\n  status: TaskStatus;\r\n  scopeToHandle: object | null;\r\n  abort: VoidFunction;\r\n  beforeExecute: VoidFunction;\r\n  // cleanup: VoidFunction;\r\n  isClean: boolean;\r\n  onExecutedListeners: VoidFunction[] | null;\r\n  internalOnExecutedListeners: VoidFunction[] | null;\r\n  abortListeners: VoidFunction[] | null;\r\n  // cleanup: VoidFunction;\r\n}\r\n\r\nexport interface ZoneMinApi {\r\n  run<T>(callback: Function, applyThis?: any, applyArgs?: any[], source?: string): T;\r\n}\r\n\r\nexport interface Zone extends ZoneMinApi {\r\n  scheduleMacroTask(\r\n    source: string,\r\n    callback: Function,\r\n    data?: any,\r\n    customSchedule?: (task: ZoneTask) => void,\r\n    customCancel?: (task: ZoneTask) => void,\r\n  ): ZoneTask;\r\n}\r\n\r\nexport interface ZoneTask {\r\n  invoke: Function;\r\n}\r\n\r\nexport interface ZoneType {\r\n  current: Zone;\r\n  root: Zone;\r\n  __symbol__(name: string): string;\r\n}\r\n\r\nexport const enum TaskStatus {\r\n  Pending = 0,\r\n  Prepared = 1, //For execution;\r\n  Executing = 2,\r\n  Executed = 3,\r\n  Aborted = 4\r\n}\r\n\r\n/**\r\n * A string representation of priority.\r\n */\r\nexport type PriorityName = 'highest' | 'high' | 'normal' | 'low' | 'lowest';\r\n\r\n/**\r\n * A numeric representation of priority.\r\n */\r\nexport type PriorityLevel = 1 | 2 | 3 | 4 | 5;\r\n\r\n/**\r\n * Component input type of priority, representing priority numeric value or priority name.\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n */\r\nexport type PriorityInput = PriorityLevel | PriorityName;\r\n\r\n/**\r\n *  Concurrent task priority.\r\n *  ```\r\n *    Highest = 1\r\n *    High = 2\r\n *    Normal = 3 (Mostly a default one)\r\n *    Low = 4\r\n *    Lowest = 5\r\n *  ```\r\n */\r\nexport enum Priority {\r\n  Highest = 1,\r\n  High = 2,\r\n  Normal = 3,\r\n  Low = 4,\r\n  Lowest = 5\r\n}\r\n\r\n\r\nexport function push(heap: SchedulerTask[], node: SchedulerTask): void {\r\n  const index = heap.length;\r\n  heap.push(node);\r\n  siftUp(heap, node, index);\r\n}\r\n\r\nexport function peek(heap: SchedulerTask[]): SchedulerTask | null {\r\n  const first = heap[0];\r\n  return first === undefined ? null : first;\r\n}\r\n\r\nexport function pop(heap: SchedulerTask[]): SchedulerTask | null {\r\n  const first = heap[0];\r\n  if (first !== undefined) {\r\n    const last = heap.pop()!;\r\n    if (last !== first) {\r\n      heap[0] = last;\r\n      siftDown(heap, last, 0);\r\n    }\r\n    return first;\r\n  } else {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction siftUp(heap: SchedulerTask[], node: SchedulerTask, i: number) {\r\n  let index = i;\r\n  while (true) {\r\n    const parentIndex = (index - 1) >>> 1;\r\n    const parent = heap[parentIndex];\r\n    if (parent !== undefined && compare(parent, node) > 0) {\r\n      // The parent is larger. Swap positions.\r\n      heap[parentIndex] = node;\r\n      heap[index] = parent;\r\n      index = parentIndex;\r\n    } else {\r\n      // The parent is smaller. Exit.\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction siftDown(heap: SchedulerTask[], node: SchedulerTask, i: number) {\r\n  let index = i;\r\n  const length = heap.length;\r\n  while (index < length) {\r\n    const leftIndex = (index + 1) * 2 - 1;\r\n    const left = heap[leftIndex];\r\n    const rightIndex = leftIndex + 1;\r\n    const right = heap[rightIndex];\r\n\r\n    if (left !== undefined && compare(left, node) < 0) {\r\n      if (right !== undefined && compare(right, left) < 0) {\r\n        heap[index] = right;\r\n        heap[rightIndex] = node;\r\n        index = rightIndex;\r\n      } else {\r\n        heap[index] = left;\r\n        heap[leftIndex] = node;\r\n        index = leftIndex;\r\n      }\r\n    } else if (right !== undefined && compare(right, node) < 0) {\r\n      heap[index] = right;\r\n      heap[rightIndex] = node;\r\n      index = rightIndex;\r\n    } else {\r\n      // Neither child is smaller. Exit.\r\n      return;\r\n    }\r\n  }\r\n}\r\n\r\nfunction compare(a: SchedulerTask, b: SchedulerTask) {\r\n  // Compare sort index first, then task id.\r\n  const diff = a.sortIndex - b.sortIndex;\r\n  return diff !== 0 ? diff : a.id - b.id;\r\n}\r\n\r\n\r\nexport function coercePriority(priority: number): Priority {\r\n  return Math.round(Math.max(1, Math.min(5, priority)));\r\n}\r\n\r\n/**\r\n * @description\r\n * Converts Priority name to corresponding numeric value ('highest' => 1, 'high' => 2, 'normal' => 3, 'low' => 4, 'lowest' => 5).\r\n * @param priorityName A name of priority ('highest', 'high', 'normal', 'low', 'lowest').\r\n * @returns Numeric value of priority (1, 2, 3, 4, 5).\r\n * @throws Error in invalid priority name is provided.\r\n */\r\nexport function priorityNameToNumber(priorityName: PriorityName): PriorityLevel;\r\n/**\r\n * @description\r\n * Converts Priority name to corresponding numeric value ('highest' => 1, 'high' => 2, 'normal' => 3, 'low' => 4, 'lowest' => 5).\r\n * @param priorityName A name of priority ('highest', 'high', 'normal', 'low', 'lowest').\r\n * @param debugFn A reference to the function making the assertion (used for the error message).\r\n * @returns Numeric value of priority (1, 2, 3, 4, 5).\r\n * @throws Error in invalid priority name is provided.\r\n */\r\nexport function priorityNameToNumber(priorityName: PriorityName, debugFn: Function): PriorityLevel;\r\nexport function priorityNameToNumber(priorityName: PriorityName, debugFn: Function = priorityNameToNumber): PriorityLevel {\r\n  switch (priorityName) {\r\n    case 'highest':\r\n      return Priority.Highest;\r\n    case 'high':\r\n      return Priority.High;\r\n    case 'normal':\r\n      return Priority.Normal;\r\n    case 'low':\r\n      return Priority.Low;\r\n    case 'lowest':\r\n      return Priority.Lowest;\r\n    default:\r\n      throw new Error(`${debugFn.name}(): Provided key '${priorityName}' is not recognized as priority!`);\r\n  }\r\n}\r\n\r\n/**\r\n * @description\r\n * Transforms priority names to it's raw numeric value.\r\n * @param value Priority name ('highest', 'high', 'normal', 'low', 'lowest') or priority numeric level (1, 2, 3, 4, 5).\r\n * @returns Priority numeric level.\r\n * @see {@link PriorityInput}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n */\r\nexport function priorityInputTransform(value: PriorityInput): PriorityLevel {\r\n  if (typeof value === 'number') {\r\n    return coercePriority(value);\r\n  } else {\r\n    return priorityNameToNumber(value, priorityInputTransform);\r\n  }\r\n}\r\n\r\n/**\r\n * @description\r\n * Transforms priority names to it's raw numeric values or transforms signal to computed signal with the same manner.\r\n * @param value Priority name ('highest', 'high', 'normal', 'low', 'lowest') or priority numeric level (1, 2, 3, 4, 5) or signal providing the same values.\r\n * @see {@link PriorityInput}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link priorityInputTransform}\r\n */\r\nexport function advancePriorityInputTransform(value: PriorityInput | Signal<PriorityInput>): PriorityLevel | Signal<PriorityLevel> {\r\n  if (isSignal(value)) {\r\n    return computed(() => {\r\n      const v =  value();\r\n      if (typeof v === 'number') {\r\n      return coercePriority(v);\r\n    } else {\r\n      return priorityNameToNumber(v, advancePriorityInputTransform);\r\n  }\r\n    })\r\n  } else {\r\n    if (typeof value === 'number') {\r\n      return coercePriority(value);\r\n    } else {\r\n      return priorityNameToNumber(value, advancePriorityInputTransform);\r\n    }\r\n  }\r\n}\r\n\r\nexport const noopFn: VoidFunction = function() {}\r\n","declare const ngDevMode: boolean | undefined;\r\n\r\nexport const NG_DEV_MODE = typeof ngDevMode === 'undefined' || !!ngDevMode;\r\n","// see https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\r\n\r\nimport { ɵglobal } from \"@angular/core\"\r\nimport {\r\n  peek,\r\n  pop,\r\n  push,\r\n  SchedulerTask,\r\n  Priority,\r\n  ZoneType,\r\n  ZoneMinApi,\r\n  ZoneTask,\r\n  TaskStatus,\r\n  noopFn,\r\n  // taskCleanup\r\n} from './scheduler_utils';\r\nimport { NG_DEV_MODE } from \"../utils\";\r\n\r\ninterface FlushWorkFn {\r\n  (hasTimeRemaining: boolean, initialTime: number): boolean\r\n}\r\n\r\ndeclare const Zone: ZoneType | undefined\r\ndeclare const jasmine: object | undefined;\r\ndeclare const jest: object | undefined;\r\n\r\nconst global = ɵglobal as typeof globalThis & { Zone?: ZoneType, setImmediate(cb: Function): number };\r\n\r\nconst noopZone: ZoneMinApi = { run(cb: Function) { return cb(); } };\r\n\r\nlet getCurrentTime: () => number = null!;\r\nlet onIdle: Function = noopFn;\r\n\r\nif (typeof performance === 'object') {\r\n  if (typeof performance.now === 'function') {\r\n    getCurrentTime = function() { return performance.now(); };\r\n  }\r\n}\r\n\r\nif (getCurrentTime === null) {\r\n  getCurrentTime = function() { return Date.now() }\r\n}\r\n\r\n// Max 31 bit integer. The max integer size in V8 for 32-bit systems.\r\n// Math.pow(2, 30) - 1\r\n// 0b111111111111111111111111111111\r\nconst maxSigned31BitInt = 1073741823;\r\n\r\n// Times out immediately\r\nconst HIGHEST_PRIORITY_TIMEOUT = -1;\r\n// Eventually times out\r\nconst HIGH_PRIORITY_TIMEOUT = 250;\r\nconst NORMAL_PRIORITY_TIMEOUT = 5000;\r\nconst LOW_PRIORITY_TIMEOUT = 10000;\r\n// Never times out\r\nconst LOWEST_PRIORITY_TIMEOUT = maxSigned31BitInt;\r\n\r\n// Tasks are stored on a min heap\r\nconst taskQueue: SchedulerTask[] = [];\r\n// const timerQueue: SchedulerTask[] = [];\r\n// All the promise resolvers returned by whenIdle() function.\r\nconst idleResolvers: Function[] = [];\r\n\r\n// Incrementing id counter. Used to maintain insertion order.\r\nlet taskIdCounter = 1;\r\n\r\nlet currentTask: SchedulerTask | null = null;\r\nlet currentPriorityLevel = Priority.Normal;\r\n\r\n// This is set while performing work, to prevent re-entrancy.\r\nlet isPerformingWork = false;\r\n\r\nlet isHostCallbackScheduled = false;\r\n\r\nfunction notifyTaskListenersAndCleanup(task: SchedulerTask) {\r\n  try {\r\n    while (task.onExecutedListeners && task.onExecutedListeners.length) {\r\n      task.onExecutedListeners.shift()!();\r\n    }\r\n    while (task.internalOnExecutedListeners && task.internalOnExecutedListeners.length) {\r\n      task.internalOnExecutedListeners.shift()!();\r\n    }\r\n  } finally {\r\n    if (\r\n      (task.onExecutedListeners && task.onExecutedListeners.length) ||\r\n      (task.internalOnExecutedListeners && task.internalOnExecutedListeners.length)\r\n    ) {\r\n      notifyTaskListenersAndCleanup(task);\r\n    } /* else {\r\n      task.cleanup(); // or just task.scopeToHandle = null;\r\n       //Good reason for that will be a caching implementation;\r\n    } */\r\n  }\r\n}\r\n\r\nfunction flushWork(hasTimeRemaining: boolean, initialTime: number): boolean {\r\n  // We'll need a host callback the next time work is scheduled.\r\n  isHostCallbackScheduled = false;\r\n\r\n  isPerformingWork = true;\r\n  const previousPriorityLevel = currentPriorityLevel;\r\n  try {\r\n    return workLoop(hasTimeRemaining, initialTime);\r\n  } finally {\r\n    currentTask = null;\r\n    currentPriorityLevel = previousPriorityLevel;\r\n    isPerformingWork = false;\r\n  }\r\n}\r\n\r\nfunction workLoop(\r\n  hasTimeRemaining: boolean,\r\n  initialTime: number,\r\n  _currentTask: SchedulerTask | null = null\r\n): boolean {\r\n\r\n  let currentTime = initialTime;\r\n  if (_currentTask) {\r\n    currentTask = _currentTask;\r\n  } else {\r\n    // advanceTimers(currentTime);\r\n    currentTask = peek(taskQueue);\r\n    //<MyCode>\r\n    if (NG_DEV_MODE) {\r\n        if (currentTask) {\r\n          if (\r\n            currentTask.callback !== null &&\r\n            currentTask.status !== TaskStatus.Pending &&\r\n            currentTask.status !== TaskStatus.Prepared\r\n          ) {\r\n            throw new Error('InternalError: Peeked task in workLoop() function has incorrect status!')\r\n          }\r\n        }\r\n      }\r\n    if (currentTask && currentTask.status === TaskStatus.Pending) {\r\n      currentTask.status = TaskStatus.Prepared;\r\n    }\r\n    //</MyCode>\r\n  }\r\n  let zoneChanged = false;\r\n  const hitDeadline = () =>\r\n    currentTask &&\r\n    currentTask.expirationTime > currentTime &&\r\n    (!hasTimeRemaining || shouldYieldToHost());\r\n\r\n  if (!hitDeadline()) {\r\n    const zone = currentTask?.zone ?? noopZone;\r\n    zone.run(function() {\r\n      while (currentTask !== null && !zoneChanged) {\r\n        if (hitDeadline()) {\r\n          break;\r\n        }\r\n        const callback = currentTask.callback;\r\n        //<MyCode>\r\n        if (NG_DEV_MODE) {\r\n          if (\r\n            callback === null &&\r\n            currentTask.status !== TaskStatus.Aborted &&\r\n            currentTask.status !== TaskStatus.Executed\r\n          ) {\r\n            throw new Error('InternalError: Task with null callback is not marked as aborted or executed!')\r\n          }\r\n        }\r\n        //</MyCode>\r\n        if (typeof callback === 'function') {\r\n          currentTask.callback = null;\r\n          currentPriorityLevel = currentTask.priorityLevel;\r\n          //<MyCode>\r\n          currentTask.status = TaskStatus.Executing\r\n          currentTask.beforeExecute()\r\n          try {\r\n            callback();\r\n          } finally {\r\n            try {\r\n              notifyTaskListenersAndCleanup(currentTask);\r\n            } finally {\r\n              currentTask.status = TaskStatus.Executed;\r\n              currentTime = getCurrentTime();\r\n            }\r\n          }\r\n        }\r\n        if (currentTask === peek(taskQueue)) {\r\n          pop(taskQueue);\r\n        }\r\n        //</MyCode>\r\n        currentTask = peek(taskQueue);\r\n        //<MyCode>\r\n        if (currentTask && currentTask.status === TaskStatus.Pending) {\r\n          currentTask.status = TaskStatus.Prepared;\r\n        }\r\n        //</MyCode>\r\n        zoneChanged = currentTask?.zone !== zone;\r\n      }\r\n    });\r\n  }\r\n  // we need to check if leaving `NgZone` (tick => detectChanges) caused other\r\n  // directives to add tasks to the queue. If there is one and we still didn't\r\n  // hit the deadline, run the workLoop again in order to flush everything thats\r\n  // left.\r\n  // Otherwise, newly added tasks won't run as `performingWork` is still `true`\r\n  currentTask = currentTask ?? peek(taskQueue);\r\n  //<MyCode>\r\n  if (currentTask && currentTask.status === TaskStatus.Pending) {\r\n    currentTask.status = TaskStatus.Prepared;\r\n  }\r\n  //</MyCode>\r\n  // We should also re-calculate the currentTime, as we need to account for the execution\r\n  // time of the NgZone tasks as well.\r\n  // If there is still a task in the queue, but no time is left for executing it,\r\n  // the scheduler will re-schedule the next tick anyway\r\n  currentTime = getCurrentTime();\r\n  if (zoneChanged || (currentTask && !hitDeadline())) {\r\n    return workLoop(hasTimeRemaining, currentTime, currentTask);\r\n  }\r\n  // Return whether there's additional work\r\n  if (currentTask !== null) {\r\n    return true;\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function scheduleCallback(\r\n  priorityLevel: Priority,\r\n  callback: VoidFunction,\r\n): SchedulerTask {\r\n  const startTime = getCurrentTime();\r\n\r\n  let expirationTime: number;\r\n  switch (priorityLevel) {\r\n    case Priority.Highest:\r\n      expirationTime = HIGHEST_PRIORITY_TIMEOUT;\r\n      break;\r\n    case Priority.High:\r\n      expirationTime = HIGH_PRIORITY_TIMEOUT;\r\n      break;\r\n    case Priority.Lowest:\r\n      expirationTime = LOWEST_PRIORITY_TIMEOUT;\r\n      break;\r\n    case Priority.Low:\r\n      expirationTime = LOW_PRIORITY_TIMEOUT;\r\n      break;\r\n    case Priority.Normal:\r\n    default:\r\n      expirationTime = NORMAL_PRIORITY_TIMEOUT;\r\n      break;\r\n  }\r\n\r\n\r\n  const newTask: SchedulerTask = {\r\n    id: taskIdCounter++,\r\n    callback,\r\n    priorityLevel,\r\n    expirationTime,\r\n    startTime,\r\n    sortIndex: -1,\r\n    zone: global.Zone?.current ?? noopZone,\r\n    status: TaskStatus.Pending,\r\n    scopeToHandle: null,\r\n    abort: noopFn,\r\n    beforeExecute: noopFn,\r\n    isClean: true,\r\n    onExecutedListeners: null,\r\n    internalOnExecutedListeners: null,\r\n    abortListeners: null,\r\n    // cleanup: taskCleanup <-- Maybe if there will be implemented caching, then there is good reason to cleanup after task was executed, setting scopeToHandle to null;\r\n  };\r\n\r\n  newTask.sortIndex = expirationTime;\r\n  push(taskQueue, newTask);\r\n  // Schedule a host callback, if needed. If we're already performing work,\r\n  // wait until the next time we yield.\r\n  if (isHostCallbackScheduled && isPerformingWork) { return newTask };\r\n  isHostCallbackScheduled = true;\r\n  requestHostCallback(flushWork);\r\n\r\n  // <<<<----Perfect place for initialization logic.---->>>>\r\n\r\n  // <<<<////Perfect place for initialization logic.---->>>>\r\n\r\n  return newTask;\r\n}\r\n\r\n/**\r\n * Waits until the task queue is considered \"idle\" by repeatedly checking\r\n * whether any tasks remain in the `taskQueue`. This is useful in unit tests\r\n * to defer assertions or teardown logic until all microtasks have settled.\r\n *\r\n * The function ensures at least 5 microtask passes (or the given number of attempts,\r\n * whichever is greater) before resolving, to give time for queued tasks to complete.\r\n *\r\n * If the queue is not empty, the `resolve` callback is added to a shared\r\n * `idleResolvers` list to be triggered once the queue clears.\r\n *\r\n * @param attempts - The number of times to check for queue emptiness. Minimum is 5.\r\n * @returns A Promise that resolves when the system appears to be idle.\r\n * @throws `Error` if supported test runner was not detected (jasmine/jest).\r\n *\r\n * @example\r\n * ```ts\r\n * it('should wait until all microtasks are flushed', async () => {\r\n *   await whenIdle();\r\n *   expect(callbackSpy).toHaveBeenCalled();\r\n * });\r\n * ```\r\n */\r\nexport function whenIdle(attempts: number = 5): Promise<void> {\r\n\r\n  if (typeof jasmine === 'undefined' && typeof jest === 'undefined') {\r\n    throw new Error('whenIdle(): Supported test runner not detected! This function can by used in supported test frameworks (jasmine/jest).')\r\n  }\r\n\r\n  return new Promise((resolve) => {\r\n    let counter = 0;\r\n    attempts = Math.max(5, Math.round(attempts));\r\n\r\n    const addToQueueOrResolve = () => {\r\n      queueMicrotask(() => {\r\n        if (counter >= attempts) {\r\n        resolve();\r\n        return;\r\n      }\r\n\r\n      if (taskQueue.length) {\r\n        idleResolvers.push(resolve);\r\n        return;\r\n      }\r\n\r\n      counter++\r\n      addToQueueOrResolve();\r\n      });\r\n    }\r\n\r\n    addToQueueOrResolve();\r\n  });\r\n}\r\n\r\n/**\r\n * Determines that the current stack frame is within concurrent task context.\r\n * @returns True if current stack frame is within concurrent task context.\r\n */\r\nexport function isInConcurrentTaskContext(): boolean {\r\n  return currentTask !== null && currentTask.status === TaskStatus.Executing;\r\n}\r\n\r\n/**\r\n * Asserts that the current stack frame is within an concurrent task context.\r\n * @param message Error message when assertion failed!.\r\n */\r\nexport function assertInConcurrentTaskContext(message?: string): void {\r\n  if (isInConcurrentTaskContext()) { return; }\r\n  message = message ?? 'assertInConcurrentTaskContext(): assertion failed!';\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Determines that the current stack frame is within concurrent task context and that task is clean.\r\n * @returns True if current stack frame is within concurrent task context and that task is clean.\r\n */\r\nexport function isInConcurrentCleanTaskContext(): boolean {\r\n  return currentTask !== null && currentTask.status === TaskStatus.Executing && currentTask.isClean;\r\n}\r\n\r\n/**\r\n * Asserts that the current stack frame is within an concurrent task context and that task is clean.\r\n * @param message Error message when assertion failed!.\r\n */\r\nexport function assertInConcurrentCleanTaskContext(message?: string): void {\r\nif (isInConcurrentCleanTaskContext()) { return; }\r\n  message = message ?? 'assertInConcurrentCleanTaskContext(): assertion failed!';\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Determines that the current stack frame is within concurrent task context and that task is dirty.\r\n * @returns True if current stack frame is within concurrent task context and that task is dirty.\r\n */\r\nexport function isInConcurrentDirtyTaskContext(): boolean {\r\n  return currentTask !== null && currentTask.status === TaskStatus.Executing && !currentTask.isClean;\r\n}\r\n\r\n/**\r\n * Asserts that the current stack frame is within an concurrent task context and that task is dirty.\r\n * @param message Error message when assertion failed!.\r\n */\r\nexport function assertInConcurrentDirtyTaskContext(message?: string): void {\r\n  if (isInConcurrentDirtyTaskContext()) { return; }\r\n  message = message ?? 'assertInConcurrentDirtyTaskContext(): assertion failed!';\r\n  throw new Error(message);\r\n}\r\n\r\n/**\r\n * Adds additional work to current executing task, still in the same context. Below example illustrates usage of\r\n * this function.\r\n * ```ts\r\n *  if (isConcurrentTaskContext()) {\r\n *    onTaskExecuted(() => {\r\n *      // Some additional work.\r\n *    });\r\n *\r\n *    onTaskExecuted(() => {\r\n *      // Some additional work.\r\n *    });\r\n *  }\r\n * ```\r\n * Keep in mind thad once added listener can not be removed.\r\n *\r\n * @param listener A function what will be invoke right after current task callback.\r\n * @throws If called outside concurrent task context.\r\n */\r\nexport function onTaskExecuted(listener: VoidFunction): void {\r\n  assertInConcurrentTaskContext('onTaskExecuted(): Stack frame is not in concurrent task context');\r\n  (currentTask!.onExecutedListeners ??= []).push(listener);\r\n}\r\n\r\nexport function getCurrentTask(): SchedulerTask | null {\r\n  return currentTask\r\n}\r\n\r\n/**\r\n * Determines that there is any tasks object in queue. If there is at least one task of any status (executed, executing, pending, aborted) it returns false.\r\n * Otherwise return true. This functions can be used in supported test runners (jest/jasmine). If any of mentioned test runners will be not detected, it will\r\n * throw an error.\r\n */\r\nexport function isTaskQueueEmpty(): boolean {\r\n  if (typeof jasmine === 'undefined' && typeof jest === 'undefined') {\r\n    throw new Error('isTaskQueueEmpty(): Supported test runner not detected! This function can by used in supported test frameworks (jasmine/jest).')\r\n  }\r\n  return taskQueue.length === 0;\r\n}\r\n\r\nexport function internalIsTaskQueueEmpty(): boolean {\r\n  return taskQueue.length === 0;\r\n}\r\n\r\nexport function getQueueLength(): number {\r\n  return taskQueue.length;\r\n}\r\n\r\nexport function getTaskAt(index: number): SchedulerTask {\r\n  return taskQueue[index];\r\n}\r\n\r\nexport function setOnIdle(fn: Function | null): void {\r\n  fn ? onIdle = fn : onIdle = noopFn;\r\n}\r\n\r\n\r\nlet isMessageLoopRunning = false;\r\nlet scheduledHostCallback: FlushWorkFn | null = null;\r\n\r\n// Scheduler periodically yields in case there is other work on the main\r\n// thread, like user events. By default, it yields multiple times per frame.\r\n// It does not attempt to align with frame boundaries, since most tasks don't\r\n// need to be frame aligned; for those that do, use requestAnimationFrame.\r\nlet yieldInterval = 16;\r\nlet needsPaint = false;\r\nlet queueStartTime = -1;\r\n\r\nfunction shouldYieldToHost() {\r\n  if (needsPaint) {\r\n    // There's a pending paint (signaled by `requestPaint`). Yield now.\r\n    return true;\r\n  }\r\n  const timeElapsed = getCurrentTime() - queueStartTime;\r\n  if (timeElapsed < yieldInterval) {\r\n    // The main thread has only been blocked for a really short amount of time;\r\n    // smaller than a single frame. Don't yield yet.\r\n    return false;\r\n  }\r\n\r\n  // `isInputPending` isn't available. Yield now.\r\n  return true;\r\n}\r\n\r\n// export function forceFrameRate(fps: number) {\r\n//   if (fps < 0 || fps > 125) {\r\n//     if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n//       console.error(\r\n//         'forceFrameRate takes a positive int between 0 and 125, ' +\r\n//           'forcing frame rates higher than 125 fps is not supported',\r\n//       );\r\n//     }\r\n//     return;\r\n//   }\r\n//   if (fps > 0) {\r\n//     yieldInterval = Math.floor(1000 / fps);\r\n//   } else {\r\n//     // reset the framerate\r\n//     yieldInterval = 5;\r\n//   }\r\n//   // be aware of browser housekeeping work (~6ms per frame)\r\n//   // according to https://developers.google.com/web/fundamentals/performance/rendering\r\n//   yieldInterval = Math.max(5, yieldInterval - 6);\r\n// }\r\n//<MyCode>\r\n// forceFrameRate(60);\r\n//</MyCode>\r\nconst performWorkUntilDeadline = function() {\r\n  if (scheduledHostCallback !== null) {\r\n    const currentTime = getCurrentTime();\r\n    // Yield after `yieldInterval` ms, regardless of where we are in the vsync\r\n    // cycle. This means there's always time remaining at the beginning of\r\n    // the message event.\r\n    queueStartTime = currentTime;\r\n    const hasTimeRemaining = true;\r\n\r\n    // If a scheduler task throws, exit the current browser task so the\r\n    // error can be observed.\r\n    //\r\n    // Intentionally not using a try-catch, since that makes some debugging\r\n    // techniques harder. Instead, if `scheduledHostCallback` errors, then\r\n    // `hasMoreWork` will remain true, and we'll continue the work loop.\r\n    let hasMoreWork = true;\r\n    try {\r\n      hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\r\n    } finally {\r\n      if (hasMoreWork) {\r\n        // If there's more work, schedule the next message event at the end\r\n        // of the preceding one.\r\n        schedulePerformWorkUntilDeadline();\r\n      } else {\r\n        isMessageLoopRunning = false;\r\n        scheduledHostCallback = null;\r\n\r\n        // <<<<----Perfect place for hook and some cleanup logic. After all work compleat.---->>>>\r\n        // Notifying that state is idle specs (see whenIdle() function in this file).\r\n        while (idleResolvers.length) {\r\n          idleResolvers.shift()!();\r\n        }\r\n        // Rising onIdle hook.\r\n        onIdle();\r\n        // <<<<////Perfect place for hook and some cleanup logic. After all work compleat.---->>>>\r\n      }\r\n    }\r\n  } else {\r\n    isMessageLoopRunning = false;\r\n  }\r\n  // Yielding to the browser will give it a chance to paint, so we can\r\n  // reset this.\r\n  needsPaint = false;\r\n};\r\n\r\nlet schedulePerformWorkUntilDeadline: () => void;\r\nif (typeof global.setImmediate === 'function') {\r\n  // Node.js and old IE.\r\n  // There's a few reasons for why we prefer setImmediate.\r\n  //\r\n  // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\r\n  // (Even though this is a DOM fork of the Scheduler, you could get here\r\n  // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\r\n  // https://github.com/facebook/react/issues/20756\r\n  //\r\n  // But also, it runs earlier which is the semantic we want.\r\n  // If other browsers ever implement it, it's better to use it.\r\n  // Although both of these would be inferior to native scheduling.\r\n  schedulePerformWorkUntilDeadline = () => {\r\n     global.setImmediate(performWorkUntilDeadline);\r\n  };\r\n} else if (typeof global.MessageChannel !== 'undefined') {\r\n\r\n\r\n  const channel = new  global.MessageChannel();\r\n  const port = channel.port2;\r\n\r\n  if (typeof Zone === 'undefined') {\r\n\r\n    channel.port1.onmessage = performWorkUntilDeadline;\r\n    schedulePerformWorkUntilDeadline = function () {\r\n      port.postMessage(null);\r\n    };\r\n\r\n  } else {\r\n\r\n    let zoneTask: ZoneTask = null!\r\n    const noopFn = () => {};\r\n    const schedulerFn = (task: ZoneTask) => {\r\n      zoneTask = task;\r\n      port.postMessage(null)\r\n    }\r\n\r\n    channel.port1.onmessage = function() { zoneTask.invoke(); }\r\n\r\n    schedulePerformWorkUntilDeadline = function() {\r\n        Zone.current.scheduleMacroTask(\r\n        'setImmediate',\r\n        performWorkUntilDeadline,\r\n        { isPeriodic: false, args: [] },\r\n        schedulerFn,\r\n        noopFn,\r\n      );\r\n    }\r\n\r\n  }\r\n\r\n} else {\r\n  // We should only fallback here in non-browser environments.\r\n  schedulePerformWorkUntilDeadline = function() {\r\n    global.setTimeout(performWorkUntilDeadline, 0);\r\n  };\r\n}\r\n\r\nfunction requestHostCallback(callback: FlushWorkFn) {\r\n  scheduledHostCallback = callback;\r\n  if (!isMessageLoopRunning) {\r\n    isMessageLoopRunning = true;\r\n    schedulePerformWorkUntilDeadline();\r\n  }\r\n}\r\n","import type { Subscription } from \"rxjs\"\r\nimport type { scheduleTask, scheduleChangeDetection, detectChanges, detectChangesSync } from \"../instructions/instructions\"\r\nimport { isPlatformServer } from \"@angular/common\";\r\nimport {\r\n  APP_BOOTSTRAP_LISTENER,\r\n  ApplicationRef,\r\n  assertInInjectionContext,\r\n  ComponentRef,\r\n  EnvironmentInjector,\r\n  EnvironmentProviders,\r\n  inject,\r\n  Injectable,\r\n  Injector,\r\n  makeEnvironmentProviders,\r\n  NgModuleRef,\r\n  OnDestroy,\r\n  PendingTasks,\r\n  PLATFORM_ID,\r\n  provideEnvironmentInitializer,\r\n  reflectComponentType,\r\n} from \"@angular/core\";\r\nimport { internalIsTaskQueueEmpty, setOnIdle } from \"../scheduler/scheduler\";\r\nimport { TestBed } from \"@angular/core/testing\";\r\n\r\ndeclare const ngDevMode: boolean | undefined;\r\ndeclare const jest: any;\r\ndeclare const jasmine: any;\r\n\r\nexport const USAGE_EXAMPLE_IN_UNIT_TESTS =\r\n  'beforeEach(() => {\\n' +\r\n  ' TestBed.configureTestingModule({\\n' +\r\n  '   providers: [\\n' +\r\n  '     provideNgQueuexIntegration()\\n' +\r\n  '   ]\\n' +\r\n  ' }).runInInjectionContext(() => {\\n' +\r\n  '   completeIntegrationForTest();\\n' +\r\n  ' });\\n'\r\n  '});\\n' +\r\n  'afterEach(() => {\\n' +\r\n  ' TestBed.resetTestingModule(); //Dispose integration between tests\\n' +\r\n  '});';\r\n\r\nexport const INTEGRATION_NOT_PROVIDED_MESSAGE =\r\n  '\"@ng-queuex/core\" integration was not provided to Angular! ' +\r\n  'Use provideNgQueuexIntegration() function to in bootstrapApplication() function ' +\r\n  'to add crucial environment providers for integration.';\r\n\r\nexport const SERVER_SIDE_MESSAGE = 'Scheduling concurrent tasks on server is not allowed!'\r\nexport const INTEGRATION_NOT_COMPLETED_MESSAGE =\r\n  '\"@ng-queuex/core\" integration for tests is not competed. To make sure that integration is finalized ' +\r\n  'use \\'completeIntegrationForTest()\\' function inside TestBed injection context as the example below shows:\\n\\n' + USAGE_EXAMPLE_IN_UNIT_TESTS\r\n\r\nconst COMMON_MESSAGE =\r\n'\"@ng-queuex/core\" is design for projects with standalone angular application where there ' +\r\n'is only one ApplicationRef instance and with one root bootstrapped component. ' +\r\n'Integration can not be provided in lazy loaded module but only at application root level ' +\r\n'and at root injection context of environment injector. Use bootstrapApplication() ' +\r\n'function with a standalone component. In case of unit tests you need to provide integration ' +\r\n'to test module and call function completeINtegrationForTest() in TestBed injection context ' +\r\n'just like example shows: \\n\\n' + USAGE_EXAMPLE_IN_UNIT_TESTS;\r\n\r\n\r\n@Injectable({ providedIn: 'root' })\r\nexport class Integrator implements OnDestroy {\r\n  public appRef = inject(ApplicationRef);\r\n  public pendingNgTasks = inject(PendingTasks);\r\n  public pendingNgTaskCleanup: (() => void) | null = null;\r\n  public bootstrapCount = 0;\r\n  public uncompleted = true;\r\n  public testEnv = false;\r\n  public isServer = isPlatformServer(inject(PLATFORM_ID));\r\n  public subscription: Subscription | null = null;\r\n  public static instance: Integrator | null = null;\r\n\r\n  constructor() {\r\n    if (Integrator.instance) {\r\n      throw new Error(\r\n        'provideNgQueuexIntegration(): Integration already provided! ' + COMMON_MESSAGE\r\n      )\r\n    }\r\n    Integrator.instance = this;\r\n  }\r\n\r\n  public assertInRoot(): void {\r\n    if (this.appRef.injector === inject(Injector)) { return; }\r\n    throw new Error(\r\n      'provideNgQueuexIntegration(): Integration provided not at root level! ' + COMMON_MESSAGE\r\n    );\r\n  }\r\n\r\n  public assertProject(): void {\r\n    if (inject(NgModuleRef).instance === null) { return; }\r\n    throw new Error(\r\n      'provideNgQueuexIntegration(): Non-standalone application detected. ' +\r\n      'This library only supports Angular applications bootstrapped with standalone APIs. ' +\r\n      'It seems that your application is still using the traditional NgModule-based ' +\r\n      'bootstrap (e.g. platformBrowserDynamic().bootstrapModule(AppModule)).'\r\n    )\r\n  }\r\n\r\n  public integrateWithAngular(): void {\r\n    this.pendingNgTaskCleanup = this.pendingNgTasks.add();\r\n    setOnIdle(() => {\r\n      this.pendingNgTaskCleanup?.();\r\n      this.pendingNgTaskCleanup = null;\r\n    });\r\n    const subscription = this.subscription = this.appRef.isStable.subscribe((value) => {\r\n      if (value) {\r\n        setOnIdle(null);\r\n        subscription.unsubscribe();\r\n      }\r\n    });\r\n    this.uncompleted = false;\r\n  }\r\n\r\n  public onBootstrap(cmpRef: ComponentRef<unknown>): void {\r\n    if (this.bootstrapCount >= 1) {\r\n      throw new Error(\r\n      'provideNgQueuexIntegration(): Multiple components were bootstrapped, which is not allowed! ' + COMMON_MESSAGE\r\n      );\r\n    }\r\n    if (typeof ngDevMode === 'undefined' || ngDevMode) {\r\n      if(!reflectComponentType(cmpRef.componentType)!.isStandalone) {\r\n        throw new Error(\r\n          'provideNgQueuexIntegration(): Application bootstrap with NgModule is not supported! '+\r\n          'Use a standalone component instead.' + COMMON_MESSAGE\r\n        )\r\n      }\r\n    }\r\n\r\n    if (++this.bootstrapCount >= this.appRef.components.length && internalIsTaskQueueEmpty()) {\r\n        // During bootstrap there was not scheduled any concurrent task.\r\n        // That means that internal onIdle hook will not be invoke, so we need to cleanup\r\n        // angular pending task manually. That will stabilize application and do rest of the cleanup.\r\n        this.pendingNgTaskCleanup?.()\r\n    }\r\n\r\n  }\r\n\r\n  ngOnDestroy(): void {\r\n    this.pendingNgTaskCleanup?.();\r\n    this.pendingNgTaskCleanup = null;\r\n    this.subscription?.unsubscribe();\r\n    this.subscription = null;\r\n    Integrator.instance = null;\r\n    setOnIdle(null);\r\n  }\r\n}\r\n\r\n/**\r\n * @description\r\n * Provides integration with angular which enables the use of `scheduleTask()` `scheduleChangeDetection()` `detectChanges()` `detectChangesSync()`\r\n * functions and provides compatibility with hydration if zoneless change detection is provided.\r\n *\r\n * In unit tests integration can be provided to test module fallowed by `completeIntegrationForTest()` function called in injection context.\r\n * The example below illustrates this best.\r\n *\r\n * ```ts\r\n *  beforeEach(() => {\r\n *    TestBed.configureTestingModule({\r\n *      providers: []\r\n *    }).runInInjectionContext(() => {\r\n *      completeIntegrationForTest();\r\n *    })\r\n *  };\r\n *  afterEach(() => {\r\n *    TestBed.resetTestingModule(); //To dispose integration between tests\r\n *  });\r\n * ```\r\n *\r\n * @returns Environment providers\r\n * @see {@link EnvironmentProviders}\r\n * @see {@link completeIntegrationForTest}\r\n * @see {@link scheduleTask}\r\n * @see {@link scheduleChangeDetection}\r\n * @see {@link detectChanges}\r\n * @see {@link detectChangesSync}\r\n * @see {@link assertNgQueuexIntegrated}\r\n */\r\nexport function provideNgQueuexIntegration(): EnvironmentProviders {\r\n  return makeEnvironmentProviders([\r\n    provideEnvironmentInitializer(() => {\r\n      const integrator = inject(Integrator);\r\n      integrator.assertInRoot();\r\n      if ((typeof jasmine === 'object' && jasmine !== null) || (typeof jest === 'object' && jest !== null)) { return; }\r\n      integrator.assertProject();\r\n      integrator.integrateWithAngular();\r\n    }),\r\n    {\r\n      provide: APP_BOOTSTRAP_LISTENER,\r\n      multi: true,\r\n      useValue: (cmpRef: ComponentRef<unknown>) => {\r\n        Integrator.instance!.onBootstrap(cmpRef);\r\n      }\r\n    }\r\n  ]);\r\n}\r\n\r\n/**\r\n * Finalizes the \"@ng-queuex/core\" integration inside a TestBed context.\r\n *\r\n * This function must be called when using `provideNgQueuexIntegration()`\r\n * within Angular's testing utilities, to ensure all test-related hooks\r\n * (Jasmine/Jest detection, schedulers, etc.) are correctly initialized.\r\n *\r\n * Usage example:\r\n * ```ts\r\n *  beforeEach(() => {\r\n *    TestBed.configureTestingModule({\r\n *      providers: [provideNgQueuexIntegration()]\r\n *    }).runInInjectionContext(() => {\r\n *      completeIntegrationForTest();\r\n *    });\r\n *  });\r\n *  afterEach(() => {\r\n *    TestBed.resetTestingModule() //To dispose integration between tests.\r\n *  });\r\n * ```\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function completeIntegrationForTest(): void {\r\n  assertInInjectionContext(() => 'completeIntegrationForTest(): This function was not used in injection context!');\r\n\r\n  if (Integrator.instance === null) {\r\n    throw new Error(\r\n      'completeIntegrationForTest(): Integration not provided! To complete integration \"@ng-queuex/core\" integration for test, ' +\r\n      'provide integration to test module:\\n\\n' + USAGE_EXAMPLE_IN_UNIT_TESTS\r\n    )\r\n  }\r\n\r\n  const testBedInjector = TestBed.inject(EnvironmentInjector);\r\n\r\n  if ((testBedInjector !== inject(Injector)) || Integrator.instance.appRef.injector !== testBedInjector) {\r\n    throw new Error(\r\n      'completeIntegrationForTest(): Incorrect function usage. This function can be used only in TestBed injection context.' +\r\n      'The correct usage of this function is illustrated in the following example:\\n\\n' + USAGE_EXAMPLE_IN_UNIT_TESTS\r\n    )\r\n  }\r\n\r\n  if (Integrator.instance.uncompleted) {\r\n    Integrator.instance.uncompleted = false;\r\n    Integrator.instance.testEnv = true;\r\n  } else {\r\n    if (Integrator.instance.testEnv) { return; }\r\n    throw new Error('completeIntegrationForTest(): This function must be called within a test runner (Jasmine/Jest). No test framework detected.')\r\n  }\r\n}\r\n\r\n/**\r\n * @description\r\n * Asserts that function `provideNgQueuexIntegration()` was used.\r\n *\r\n * @param message An error message.\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function assertNgQueuexIntegrated(message?: string): void {\r\n  if (Integrator.instance) {\r\n    if (Integrator.instance.uncompleted) {\r\n      message = message ?? 'assertNgQueuexIntegrationProvided(): assertion failed! Integration not completed.';\r\n      throw new Error(message);\r\n    }\r\n    return;\r\n  }\r\n  message = message ?? 'assertNgQueuexIntegrationProvided(): assertion failed! Integration not provided.';\r\n  throw new Error(message);\r\n}\r\n","import type {\r\n  assertInConcurrentTaskContext,\r\n  assertInConcurrentCleanTaskContext,\r\n  assertInConcurrentDirtyTaskContext,\r\n  isInConcurrentDirtyTaskContext\r\n} from \"../scheduler/scheduler\";\r\nimport type {\r\n  provideNgQueuexIntegration\r\n} from \"../environment/environment\";\r\nimport {\r\n  ChangeDetectorRef,\r\n} from \"@angular/core\";\r\nimport {\r\n  coercePriority,\r\n  noopFn,\r\n  Priority,\r\n  SchedulerTask,\r\n  TaskStatus,\r\n  PriorityLevel,\r\n  PriorityName\r\n} from \"../scheduler/scheduler_utils\";\r\nimport {\r\n  getCurrentTask,\r\n  isInConcurrentCleanTaskContext,\r\n  isInConcurrentTaskContext,\r\n  scheduleCallback\r\n} from \"../scheduler/scheduler\";\r\nimport { INTEGRATION_NOT_COMPLETED_MESSAGE, INTEGRATION_NOT_PROVIDED_MESSAGE, Integrator, SERVER_SIDE_MESSAGE, USAGE_EXAMPLE_IN_UNIT_TESTS } from \"../environment/environment\";\r\nimport { NG_DEV_MODE } from \"../utils\";\r\n\r\nconst coalescingScopes = new WeakMap<object, SchedulerTask>();\r\n\r\n/**\r\n * @description\r\n * An interface describing task aborting function. Invoking this function without arguments will abort task. However if you provide a function, it will not abort task but instead it\r\n * will set a callback what will run when task gets aborted. If there already is a callback, it will be overridden.\r\n */\r\nexport interface AbortTaskFunction {\r\n  /**\r\n   * @description\r\n   * Aborting task call.\r\n   */\r\n  (): void;\r\n  addAbortListener(listener: VoidFunction): void;\r\n  removeAbortListener(listener: VoidFunction): void;\r\n}\r\n\r\n/**\r\n * @description\r\n * Schedules a task with default priority (`Priority.Normal`) what will trigger cdRef.detectChanges() method, unless it was schedules earle before\r\n * with same or higher priority. Under the hood there is coalescing mechanism implement.\r\n *\r\n * Lest look at this example.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    detectChanges(this._cdRef); // Task successfully scheduled.\r\n *    detectChanges(this._cdRef); // Scheduling prevented.\r\n *    detectChanges(this._cdRef); // Scheduling prevented.\r\n *  }\r\n * ```\r\n * In example above change detection is coalesced. Lets consider different example with task abortion.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    const abort = detectChanges(this._cdRef); // Task successfully scheduled.\r\n *    abort() // Task from above is now aborted.\r\n *    detectChanges(this._cdRef); // Task successfully scheduled.\r\n *    detectChanges(this._cdRef); // Scheduling prevented.\r\n *  }\r\n * ```\r\n * From this now you know how you can delegate change detection to other task. There is also one more scenario when task can be aborted without\r\n * calling abort function.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    detectChanges(this._cdRef); // Task successfully scheduled, but will be aborted.\r\n *    detectChanges(this._cdRef); // Scheduling prevented.\r\n *\r\n *    // Previous task is aborted and change detection is rescheduled, to be executed earlier.\r\n *    detectChanges(this._cdRef, Priority.High);\r\n *  }\r\n * ```\r\n * Change detection scheduled with higher priority will abort this one with lower. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param cdRef A component `ChangeDetectorRef` or `ViewRef` of the embedded view.\r\n * @returns Abort task function if change detection was successfully scheduled. Null if change detection was coalesced.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link ChangeDetectorRef}\r\n * @see ViewRef from \"@angular/core\"\r\n * @see EmbeddedViewRef from \"@angular/core\"\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function detectChanges(cdRef: ChangeDetectorRef): AbortTaskFunction | null;\r\n/**\r\n * @description\r\n * Schedules a task with default priority (`Priority.Normal`) what will trigger cdRef.detectChanges() method, unless it was schedules earle before\r\n * with same or higher priority. Under the hood there is coalescing mechanism implement.\r\n *\r\n * Lest look at this example.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    detectChanges(this._cdRef, Priority.Normal); // Task successfully scheduled.\r\n *    detectChanges(this._cdRef, Priority.Normal); // Scheduling prevented.\r\n *    detectChanges(this._cdRef, Priority.Normal); // Scheduling prevented.\r\n *  }\r\n * ```\r\n * In example above change detection is coalesced. Lets consider different example with task abortion.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    const abort = detectChanges(this._cdRef, Priority.Normal); // Task successfully scheduled.\r\n *    abort() // Task from above is now aborted.\r\n *    detectChanges(this._cdRef, Priority.Normal); // Task successfully scheduled.\r\n *    detectChanges(this._cdRef, Priority.Normal); // Scheduling prevented.\r\n *  }\r\n * ```\r\n * From this now you know how you can delegate change detection to other task. There is also one more scenario when task can be aborted without\r\n * calling abort function.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectorRef)\r\n *\r\n *  public onButtonClick(): void {\r\n *    detectChanges(this._cdRef, Priority.Normal); // Task successfully scheduled, but will be aborted.\r\n *    detectChanges(this._cdRef, Priority.Normal); // Scheduling prevented.\r\n *\r\n *    // Previous task is aborted and change detection is rescheduled, to be executed earlier.\r\n *    detectChanges(this._cdRef, Priority.High);\r\n *  }\r\n * ```\r\n * Change detection scheduled with higher priority will abort this one with lower. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param cdRef A component `ChangeDetectorRef` or `ViewRef` of the embedded view.\r\n * @param priority Concurrent task execution priority.\r\n * @returns Abort task function if change detection was successfully scheduled. Null if change detection was coalesced.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link ChangeDetectorRef}\r\n * @see ViewRef from \"@angular/core\"\r\n * @see EmbeddedViewRef from \"@angular/core\"\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function detectChanges(cdRef: ChangeDetectorRef, priority: PriorityLevel): AbortTaskFunction | null;\r\nexport function detectChanges(cdRef: ChangeDetectorRef, priority: PriorityLevel = 3 /* Priority.Normal */): AbortTaskFunction | null {\r\n\r\n  if (NG_DEV_MODE) {\r\n    if (Integrator.instance === null) {\r\n      throw new Error('detectChanges(): ' + INTEGRATION_NOT_PROVIDED_MESSAGE);\r\n    }\r\n    if (Integrator.instance.isServer) {\r\n      throw new Error('detectChanges(): ' + SERVER_SIDE_MESSAGE);\r\n    }\r\n    if (Integrator.instance.uncompleted) {\r\n      throw new Error('detectChanges(): ' + INTEGRATION_NOT_COMPLETED_MESSAGE)\r\n    }\r\n  }\r\n\r\n  const relatedTask = coalescingScopes.get(cdRef);\r\n\r\n  if (relatedTask) {\r\n    if (NG_DEV_MODE) {\r\n      if (relatedTask.status === TaskStatus.Aborted) {\r\n        throw new Error('InternalError: Related task to CdRef is aborted to early!');\r\n      }\r\n      if (relatedTask.status === TaskStatus.Executed) {\r\n        throw new Error('InternalError: Related task to cdRef is executed but coalescing scope is not deleted!');\r\n      }\r\n    }\r\n\r\n    if (priority >= relatedTask.priorityLevel ||\r\n      relatedTask.status === TaskStatus.Prepared ||\r\n      relatedTask.status === TaskStatus.Executing\r\n    ) {\r\n      return null;\r\n    }\r\n\r\n    // At this place related task is pending.\r\n    // We need to abort this task because it has lower priority.\r\n    relatedTask.abort();\r\n  }\r\n\r\n  let task: SchedulerTask | null = scheduleCallback(coercePriority(priority), function() {\r\n    cdRef.detectChanges();\r\n  });\r\n\r\n  task.isClean = false;\r\n\r\n  coalescingScopes.set(cdRef, task);\r\n\r\n  task.beforeExecute = function() {\r\n    task = null;\r\n  };\r\n\r\n  task.internalOnExecutedListeners = [];\r\n\r\n  task.internalOnExecutedListeners.push(function () {\r\n    coalescingScopes.delete(cdRef)\r\n  })\r\n\r\n\r\n  const abortTask = function() {\r\n    if (task) {\r\n      task.callback = null;\r\n      task.status = TaskStatus.Aborted;\r\n      const abortListeners = task.abortListeners;\r\n      task = null;\r\n      coalescingScopes.delete(cdRef)\r\n      if (abortListeners) {\r\n        while(abortListeners.length) {\r\n          abortListeners.shift()!();\r\n        }\r\n      }\r\n\r\n    }\r\n  } as unknown as AbortTaskFunction;\r\n\r\n  abortTask.addAbortListener = function(listener) {\r\n    if (task) {\r\n      if (!task.abortListeners) {\r\n        task.abortListeners = []\r\n      }\r\n      task.abortListeners.push(listener);\r\n    }\r\n  }\r\n\r\n  abortTask.removeAbortListener = function(listener) {\r\n    if (task && task.abortListeners) {\r\n      const index = task.abortListeners.indexOf(listener);\r\n      if (index > -1) {\r\n        task.abortListeners.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  task.abort = abortTask;\r\n\r\n  return abortTask;\r\n}\r\n\r\n\r\n/**\r\n * @description\r\n * Schedules a task with default priority (`Priority.Normal`) and with provided callback which will be executed. The main difference\r\n * from `scheduleTask()` is that it is involved internal coalescing mechanism. Consider to use `detectChangesSync()` function to\r\n * improve coalescing. The example below illustrates how coalescing works.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectionRef);\r\n *\r\n *  public onButtonClick(): void {\r\n *    scheduleChangeDetection(() => {\r\n *      detectChangesSync(this._cdRef); //This line will trigger change detection. returns true.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *    });\r\n *  }\r\n * ```\r\n * As you can see, in concurrent task execution context you can trigger change detection once. With ```detectChanges()``` function\r\n * used side by side, there is a situation where coalescing will appear.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    // This call will abort task created bellow, because that task doesn't have a higher priority\r\n *    detectChangesSync(this._cdRef);\r\n *  });\r\n *\r\n *  detectChanges(this._cdRer); // Task successfully scheduled, but will be aborted\r\n * ```\r\n * However if you provide higher priority to `detectChanges()` function, coalescing will failed and change detection will be triggered twice.\r\n * ```ts\r\n *  //This task has default Priority.Normal.\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  });\r\n *\r\n *  // Task successfully scheduled and will be execute earlier then task from above.\r\n *  detectChanges(this._cdRer, Priority.High);\r\n * ```\r\n * For same priorities, coalescing will also failed if you change execution order.\r\n * ```ts\r\n *  //Task successfully scheduled and will be executed earlier then task below.\r\n *  detectChanges(this._cdRer);\r\n *\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  });\r\n * ```\r\n * To improve coalescing for these unfavorable scenarios, provide `cdRef` to `scheduleChangeDetection()` function,\r\n * as a third argument.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, this._cdRef);\r\n *\r\n *  detectChanges(this._cdRef);\r\n * ```\r\n * Task in witch is involved coalescing system of change detection is called `dirty task`. In contrast task created with\r\n * function `scheduleTask()` is called `clean task`. `Clean task` can be aborted only by function returned by `scheduleTask()`.\r\n *\r\n * @caution\r\n * There is nothing to prevent you to use multiple `ChangeDetectionRef` objects in callbacks body, but remember that internal coalescing\r\n * mechanism can abort dirty tasks for you. See description of `detectChanges()` function. If you want do add teardown logic to task abortion\r\n * see the description of `AbortTaskFunction` interface. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param callback Concurrent task callback.\r\n * @returns Abort task function.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link detectChangesSync}\r\n * @see {@link detectChanges}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentDirtyTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentDirtyTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleChangeDetection(callback: VoidFunction): AbortTaskFunction;\r\n/**\r\n * @description\r\n * Schedules a task with provided callback which will be executed. The main difference from `scheduleTask()` is that it is involved\r\n * internal coalescing mechanism. Consider to use `detectChangesSync()` function to improve coalescing. The example\r\n * below illustrates how coalescing works.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectionRef);\r\n *\r\n *  public onButtonClick(): void {\r\n *    scheduleChangeDetection(() => {\r\n *      detectChangesSync(this._cdRef); //This line will trigger change detection. returns true.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *    }, Priority.Normal);\r\n *  }\r\n * ```\r\n * As you can see, in concurrent task execution context you can trigger change detection once. With ```detectChanges()``` function\r\n * used side by side, there is a situation where coalescing will appear.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    // This call will abort task created bellow, because that task doesn't have a higher priority\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal);\r\n *\r\n *  detectChanges(this._cdRer); // Task successfully scheduled, but will be aborted\r\n * ```\r\n * However if you provide higher priority to `detectChanges()` function, coalescing will failed and change detection will be triggered twice.\r\n * ```ts\r\n *  //This task has default Priority.Normal.\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal);\r\n *\r\n *  // Task successfully scheduled and will be execute earlier then task from above.\r\n *  detectChanges(this._cdRer, Priority.High);\r\n * ```\r\n * For same priorities, coalescing will also failed if you change execution order.\r\n * ```ts\r\n *  //Task successfully scheduled and will be executed earlier then task below.\r\n *  detectChanges(this._cdRer);\r\n *\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal);\r\n * ```\r\n * To improve coalescing for these unfavorable scenarios, provide `cdRef` to `scheduleChangeDetection()` function,\r\n * as a third argument.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, this._cdRef);\r\n *\r\n *  detectChanges(this._cdRef);\r\n * ```\r\n * Task in witch is involved coalescing system of change detection is called `dirty task`. In contrast task created with\r\n * function `scheduleTask()` is called `clean task`. `Clean task` can be aborted only by function returned by `scheduleTask()`.\r\n *\r\n * @caution\r\n * There is nothing to prevent you to use multiple `ChangeDetectionRef` objects in callbacks body, but remember that internal coalescing\r\n * mechanism can abort tasks for you. See description of `detectChanges()` function. If you want do add teardown logic to task abortion\r\n * see the description of `AbortTaskFunction` interface. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param callback Concurrent task callback.\r\n * @param priority Task priority.\r\n * @returns Abort task function.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link detectChangesSync}\r\n * @see {@link detectChanges}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentDirtyTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentDirtyTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleChangeDetection(callback: VoidFunction, priority: PriorityLevel): AbortTaskFunction;\r\n/**\r\n * @description\r\n * Schedules a task with provided callback which will be executed. The main difference from `scheduleTask()` is that it is involved\r\n * internal coalescing mechanism. Consider to use `detectChangesSync()` function to improve coalescing. The example\r\n * below illustrates how coalescing works.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectionRef);\r\n *\r\n *  public onButtonClick(): void {\r\n *    scheduleChangeDetection(() => {\r\n *      detectChangesSync(this._cdRef); //This line will trigger change detection. returns true.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *    }, Priority.Normal, null);\r\n *  }\r\n * ```\r\n * As you can see, in concurrent task execution context you can trigger change detection once. With ```detectChanges()``` function\r\n * used side by side, there is a situation where coalescing will appear.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    // This call will abort task created bellow, because that task doesn't have a higher priority\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, null);\r\n *\r\n *  detectChanges(this._cdRer); // Task successfully scheduled, but will be aborted\r\n * ```\r\n * However if you provide higher priority to `detectChanges()` function, coalescing will failed and change detection will be triggered twice.\r\n * ```ts\r\n *  //This task has default Priority.Normal.\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal, null);\r\n *\r\n *  // Task successfully scheduled and will be execute earlier then task from above.\r\n *  detectChanges(this._cdRer, Priority.High);\r\n * ```\r\n * For same priorities, coalescing will also failed if you change execution order.\r\n * ```ts\r\n *  //Task successfully scheduled and will be executed earlier then task below.\r\n *  detectChanges(this._cdRer);\r\n *\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal, null);\r\n * ```\r\n * To improve coalescing for these unfavorable scenarios, provide `cdRef` to `scheduleChangeDetection()` function,\r\n * as a third argument.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, this._cdRef);\r\n *\r\n *  detectChanges(this._cdRef);\r\n * ```\r\n * Task in witch is involved coalescing system of change detection is called `dirty task`. In contrast task created with\r\n * function `scheduleTask()` is called `clean task`. `Clean task` can be aborted only by function returned by `scheduleTask()`.\r\n *\r\n * @caution\r\n * There is nothing to prevent you to use multiple `ChangeDetectionRef` objects in callbacks body, but remember that internal coalescing\r\n * mechanism can abort tasks for you. See description of `detectChanges()` function. If you want do add teardown logic to task abortion\r\n * see the description of `AbortTaskFunction` interface. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param callback Concurrent task callback.\r\n * @param priority Task priority.\r\n * @returns Abort task function.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link detectChangesSync}\r\n * @see {@link detectChanges}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentDirtyTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentDirtyTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleChangeDetection(callback: VoidFunction, priority: PriorityLevel, cdRef: null): AbortTaskFunction;\r\n/**\r\n * @description\r\n * Schedules a task with provided callback which will be executed. The main difference from `scheduleTask()` is that it is involved\r\n * internal coalescing mechanism. Consider to use `detectChangesSync()` function to improve coalescing. The example\r\n * below illustrates how coalescing works.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectionRef);\r\n *\r\n *  public onButtonClick(): void {\r\n *    scheduleChangeDetection(() => {\r\n *      detectChangesSync(this._cdRef); //This line will trigger change detection. returns true.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *    }, Priority.Normal);\r\n *  }\r\n * ```\r\n * As you can see, in concurrent task execution context you can trigger change detection once. With `detectChanges()` function\r\n * used side by side, there is a situation where coalescing will appear.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    // This call will abort task created bellow, because that task doesn't have a higher priority\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal);\r\n *\r\n *  detectChanges(this._cdRer); // Task successfully scheduled, but will be aborted\r\n * ```\r\n * However if you provide higher priority to `detectChanges()` function, coalescing will failed and change detection will be triggered twice.\r\n * ```ts\r\n *  //This task has default Priority.Normal.\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal);\r\n *\r\n *  // Task successfully scheduled and will be execute earlier then task from above.\r\n *  detectChanges(this._cdRer, Priority.High);\r\n * ```\r\n * For same priorities, coalescing will also failed if you change execution order.\r\n * ```ts\r\n *  //Task successfully scheduled and will be executed earlier then task below.\r\n *  detectChanges(this._cdRer);\r\n *\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal);\r\n * ```\r\n * To improve coalescing for these unfavorable scenarios, provide `cdRef` to `scheduleChangeDetection()` function,\r\n * as a third argument.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, this._cdRef);\r\n *\r\n *  detectChanges(this._cdRef);\r\n * ```\r\n * Task in witch is involved coalescing system of change detection is called `dirty task`. In contrast task created with\r\n * function `scheduleTask()` is called `clean task`. `Clean tas`` can be aborted only by function returned by `scheduleTask()`.\r\n *\r\n * @caution\r\n * There is nothing to prevent you to use multiple `ChangeDetectionRef` objects in callbacks body, but remember that internal coalescing\r\n * mechanism can abort tasks for you. See description of `detectChanges()` function. If you want do add teardown logic to task abortion\r\n * see the description of `AbortTaskFunction` interface. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param callback Concurrent task callback.\r\n * @param priority Task priority.\r\n * @param cdRef An object of type `ChangeDetectorRef` what will be potentially consumed in callbacks body or null.\r\n * @returns Abort task function if task was successfully scheduled. Null if change detection was coalesced.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link ChangeDetectorRef}\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link detectChangesSync}\r\n * @see {@link detectChanges}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentDirtyTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentDirtyTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleChangeDetection(callback: VoidFunction, priority: PriorityLevel, cdRef: ChangeDetectorRef): AbortTaskFunction | null;\r\n/**\r\n * @description\r\n * Schedules a task with provided callback which will be executed. The main difference from `scheduleTask()` is that it is involved\r\n * internal coalescing mechanism. Consider to use `detectChangesSync()` function to improve coalescing. The example\r\n * below illustrates how coalescing works.\r\n * ```ts\r\n *  private _cdRef = inject(ChangeDetectionRef);\r\n *\r\n *  public onButtonClick(): void {\r\n *    scheduleChangeDetection(() => {\r\n *      detectChangesSync(this._cdRef); //This line will trigger change detection. returns true.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *      detectChangesSync(this._cdRef); //This line not trigger change detection. returns false.\r\n *    }, Priority.Normal, null);\r\n *  }\r\n * ```\r\n * As you can see, in concurrent task execution context you can trigger change detection once. With `detectChanges()` function\r\n * used side by side, there is a situation where coalescing will appear.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    // This call will abort task created bellow, because that task doesn't have a higher priority\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, null);\r\n *\r\n *  detectChanges(this._cdRer); // Task successfully scheduled, but will be aborted\r\n * ```\r\n * However if you provide higher priority to `detectChanges()` function, coalescing will failed and change detection will be triggered twice.\r\n * ```ts\r\n *  //This task has default Priority.Normal.\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal, null);\r\n *\r\n *  // Task successfully scheduled and will be execute earlier then task from above.\r\n *  detectChanges(this._cdRer, Priority.High);\r\n * ```\r\n * For same priorities, coalescing will also failed if you change execution order.\r\n * ```ts\r\n *  //Task successfully scheduled and will be executed earlier then task below.\r\n *  detectChanges(this._cdRer);\r\n *\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef); // This call will trigger change detection.\r\n *  }, Priority.Normal, null);\r\n * ```\r\n * To improve coalescing for these unfavorable scenarios, provide `cdRef` to `scheduleChangeDetection()` function,\r\n * as a third argument.\r\n * ```ts\r\n *  scheduleChangeDetection(() => {\r\n *    detectChangesSync(this._cdRef);\r\n *  }, Priority.Normal, this._cdRef);\r\n *\r\n *  detectChanges(this._cdRef);\r\n * ```\r\n * Task in witch is involved coalescing system of change detection is called `dirty task`. In contrast task created with\r\n * function `scheduleTask()` is called `clean task`. `Clean tas`` can be aborted only by function returned by `scheduleTask()`.\r\n *\r\n * @caution\r\n * There is nothing to prevent you to use multiple `ChangeDetectionRef` objects in callbacks body, but remember that internal coalescing\r\n * mechanism can abort tasks for you. See description of `detectChanges()` function. If you want do add teardown logic to task abortion\r\n * see the description of `AbortTaskFunction` interface. Regardless of whatever the task gets aborted by you or by internal\r\n * coalescing mechanism, you can always set abort listener or even remove it.\r\n * ```ts\r\n *  const abortTask = detectChanges(this._cdRef);\r\n *\r\n *  const abortListener () => { console.log('onAbort'); }\r\n *  abortTask.addAbortListener(abortListener);\r\n *\r\n *  //later\r\n *  abortTask.removeAbortListener(abortListener);\r\n * ```\r\n *\r\n * @param callback Concurrent task callback.\r\n * @param priority Task priority.\r\n * @param cdRef An object of type `ChangeDetectorRef` what will be potentially consumed in callbacks body or null.\r\n * @returns Abort task function if task was successfully scheduled. Null if change detection was coalesced.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link ChangeDetectorRef}\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link detectChangesSync}\r\n * @see {@link detectChanges}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentDirtyTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentDirtyTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleChangeDetection(callback: VoidFunction, priority: PriorityLevel, cdRef: ChangeDetectorRef | null): AbortTaskFunction | null;\r\nexport function scheduleChangeDetection(\r\n  callback: VoidFunction,\r\n  priority: PriorityLevel = 3, //Priority.Normal\r\n  cdRef: ChangeDetectorRef | null = null,\r\n): AbortTaskFunction | null {\r\n\r\n  if (NG_DEV_MODE) {\r\n    if (Integrator.instance === null) {\r\n      throw new Error('scheduleChangeDetection(): ' + INTEGRATION_NOT_PROVIDED_MESSAGE);\r\n    }\r\n    if (Integrator.instance.isServer) {\r\n      throw new Error('scheduleChangeDetection(): ' + SERVER_SIDE_MESSAGE);\r\n    }\r\n    if (Integrator.instance.uncompleted) {\r\n      throw new Error('scheduleChangeDetection(): ' + INTEGRATION_NOT_COMPLETED_MESSAGE)\r\n    }\r\n  }\r\n\r\n  if (cdRef) {\r\n    const relatedTask = coalescingScopes.get(cdRef);\r\n\r\n    if (relatedTask) {\r\n      if (NG_DEV_MODE) {\r\n        if (relatedTask.status === TaskStatus.Aborted) {\r\n          throw new Error('InternalError: Related task to CdRef is aborted to early!');\r\n        }\r\n        if (relatedTask.status === TaskStatus.Executed) {\r\n          throw new Error('InternalError: Related task to cdRef is executed but coalescing scope is not deleted!');\r\n        }\r\n      }\r\n\r\n      if (\r\n        priority >= relatedTask.priorityLevel || // Lower priority has bigger number\r\n        relatedTask.status === TaskStatus.Prepared ||\r\n        relatedTask.status === TaskStatus.Executing\r\n      ) {\r\n        return null;\r\n      }\r\n\r\n      //We need to abort this task because it has lower priority.\r\n      relatedTask.abort();\r\n    }\r\n  }\r\n\r\n  let task: SchedulerTask | null = scheduleCallback(coercePriority(priority), callback);\r\n\r\n  task.isClean = false;\r\n\r\n  if (cdRef) {\r\n    coalescingScopes.set(cdRef, task)\r\n    task.scopeToHandle = cdRef;\r\n  }\r\n\r\n  task.beforeExecute = function() {\r\n    task = null;\r\n  }\r\n\r\n  task.internalOnExecutedListeners = [];\r\n\r\n  task.internalOnExecutedListeners.push(function() {\r\n    if (cdRef) {\r\n      coalescingScopes.delete(cdRef);\r\n    }\r\n  });\r\n\r\n  const abortTask = function() {\r\n    if (task) {\r\n      task.callback = null;\r\n      task.status = TaskStatus.Aborted;\r\n      const abortListeners = task.abortListeners;\r\n      task = null;\r\n      if (cdRef) {\r\n        coalescingScopes.delete(cdRef);\r\n      }\r\n      if (abortListeners) {\r\n        while(abortListeners.length) {\r\n          abortListeners.shift()!();\r\n        }\r\n      }\r\n    }\r\n  } as unknown as AbortTaskFunction;\r\n\r\n  abortTask.addAbortListener = function(listener) {\r\n    if (task) {\r\n      if (!task.abortListeners) {\r\n        task.abortListeners = []\r\n      }\r\n      task.abortListeners.push(listener);\r\n    }\r\n  }\r\n\r\n  abortTask.removeAbortListener = function(listener) {\r\n    if (task && task.abortListeners) {\r\n      const index = task.abortListeners.indexOf(listener);\r\n      if (index > -1) {\r\n        task.abortListeners.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  task.abort = abortTask;\r\n\r\n  return abortTask;\r\n}\r\n\r\n/**\r\n * Schedules a task with default priority (`Priority.Normal`) and with provided callback witch will be executed.\r\n * Task created with that function is called `clean task`. That means there is not involved any coalescing system related to\r\n * change detection, and that task can be aborted only by function returned by `scheduleTask()`. If you want to know more\r\n * about difference between `clean task` and `dirty task` , read a description of `scheduleChangeDetection()` function.\r\n *\r\n * @param callback Concurrent task callback.\r\n * @returns Abort task function.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentCleanTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentCleanTaskContext}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleTask(callback: VoidFunction): AbortTaskFunction;\r\n/**\r\n * Schedules a task with provided callback witch will be executed. Task created with that function is called `clean task`.\r\n * That means there is not involved any coalescing system related to change detection, and that task can be aborted only by\r\n * function returned by `scheduleTask()`. If you want to know more about difference between `clean task` and\r\n * `dirty task` , read a description of `scheduleChangeDetection()` function.\r\n *\r\n * @param callback Concurrent task callback.\r\n * @param priority Task priority.\r\n * @returns Abort task function.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link Priority}\r\n * @see {@link PriorityName}\r\n * @see {@link PriorityLevel}\r\n * @see {@link assertInConcurrentTaskContext}\r\n * @see {@link assertInConcurrentCleanTaskContext}\r\n * @see {@link isInConcurrentTaskContext}\r\n * @see {@link isInConcurrentCleanTaskContext}\r\n * @see {@link AbortTaskFunction}\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function scheduleTask(callback: VoidFunction, priority: PriorityLevel): AbortTaskFunction;\r\nexport function scheduleTask(callback: VoidFunction, priority: Priority = 3 /* Priority.Normal */): AbortTaskFunction {\r\n\r\n  if (NG_DEV_MODE) {\r\n    if (Integrator.instance === null) {\r\n      throw new Error('scheduleTask(): ' + INTEGRATION_NOT_PROVIDED_MESSAGE);\r\n    }\r\n    if (Integrator.instance.isServer) {\r\n      throw new Error('scheduleTask(): ' + SERVER_SIDE_MESSAGE);\r\n    }\r\n    if (Integrator.instance.uncompleted) {\r\n      throw new Error('scheduleTask(): ' + INTEGRATION_NOT_COMPLETED_MESSAGE)\r\n    }\r\n  }\r\n\r\n  let task: SchedulerTask | null = scheduleCallback(coercePriority(priority), callback);\r\n\r\n  task.beforeExecute = function() { task = null; }\r\n\r\n  const abortTask = function() {\r\n    if (task) {\r\n      task.callback = null;\r\n      task.status = TaskStatus.Aborted;\r\n      const abortListeners = task.abortListeners;\r\n      task = null;\r\n      if (abortListeners) {\r\n        while(abortListeners.length) {\r\n          abortListeners.shift()!();\r\n        }\r\n      }\r\n    }\r\n  } as unknown as AbortTaskFunction;\r\n\r\n  abortTask.addAbortListener = function(listener) {\r\n    if (task) {\r\n      if (!task.abortListeners) {\r\n        task.abortListeners = []\r\n      }\r\n      task.abortListeners.push(listener);\r\n    }\r\n  }\r\n\r\n  abortTask.removeAbortListener = function(listener) {\r\n    if (task && task.abortListeners) {\r\n      const index = task.abortListeners.indexOf(listener);\r\n      if (index > -1) {\r\n        task.abortListeners.splice(index, 1);\r\n      }\r\n    }\r\n  }\r\n\r\n  return abortTask\r\n}\r\n\r\n/**\r\n * @description\r\n * Tries to invoke `cdRef.detectChanges()` method synchronously, unless internal coalescing system will prevent this action.\r\n * To learn more, see descriptions of `scheduleChangeDetection()` and `detectChanges()` functions.\r\n *\r\n * @param cdRef A component `ChangeDetectorRef` or `ViewRef` of embedded view.\r\n * @returns true if succeeded, other wise it was coalesced with concurrent task.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n * @see {@link scheduleTask}\r\n * @see {@link detectChanges}\r\n * @see {@link ChangeDetectorRef}\r\n * @see ViewRef from \"@angular/core\"\r\n * @see EmbeddedViewRef from \"@angular/core\"\r\n * @see {@link provideNgQueuexIntegration}\r\n */\r\nexport function detectChangesSync(cdRef: ChangeDetectorRef): boolean {\r\n\r\n  if (NG_DEV_MODE) {\r\n    if (Integrator.instance === null) {\r\n      throw new Error('detectChangesSync(): ' + INTEGRATION_NOT_PROVIDED_MESSAGE);\r\n    }\r\n    if (Integrator.instance.isServer) {\r\n      throw new Error('detectChangesSync(): This function usage on server is not allowed!');\r\n    }\r\n    if (Integrator.instance.uncompleted) {\r\n      throw new Error('detectChangesSync(): ' + INTEGRATION_NOT_COMPLETED_MESSAGE)\r\n    }\r\n  }\r\n\r\n  if (isInConcurrentCleanTaskContext()) {\r\n    cdRef.detectChanges();\r\n    return true;\r\n  }\r\n\r\n  const relatedTask = coalescingScopes.get(cdRef);\r\n  if (relatedTask) {\r\n\r\n    //Internal Errors\r\n    if (NG_DEV_MODE) {\r\n      if (relatedTask.status === TaskStatus.Aborted) {\r\n        throw new Error('InternalError: Related task to CdRef is aborted to early!');\r\n      }\r\n      if (relatedTask.status === TaskStatus.Executed) {\r\n        throw new Error('InternalError: Related task to cdRef is executed but coalescing scope is not deleted!');\r\n      }\r\n    }\r\n\r\n    // According to internal scheduler implementation, we can not have one task marked as \"prepared\"\r\n    // and other as \"executing\". For the task what is prepared or executing, the next one in queue\r\n    // is marked as pending for sure. This is the situation where detectChangesSync() outside\r\n    // concurrent task context.\r\n    if (relatedTask.status === TaskStatus.Prepared) { return false; }\r\n\r\n    if (relatedTask.status === TaskStatus.Executing) {\r\n      if (relatedTask.scopeToHandle === cdRef) {\r\n        // scheduleChangeDetection(...) with cdRef as third arg was used to schedule this task. We must consume cdRef now.\r\n        relatedTask.scopeToHandle = null;\r\n        cdRef.detectChanges(); // Coalescing is handled by scheduleChangeDetection(...) function.\r\n        return true;\r\n      } else {\r\n        return false\r\n      }\r\n    }\r\n\r\n    //At this place related task is pending. If there is prepared task already or executing right now,\r\n    //we need abort related task and trigger cdRef.detectChanges(). if not, then nothing;\r\n    if (isInConcurrentTaskContext()) {\r\n      relatedTask.abort();\r\n      const currentTask = getCurrentTask()!;\r\n      coalescingScopes.set(cdRef, currentTask);\r\n      cdRef.detectChanges();\r\n      (currentTask.internalOnExecutedListeners ??= []).push(function() {\r\n        coalescingScopes.delete(cdRef);\r\n      });\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  } else {\r\n    // At that place we know that this cdRef was not scheduled at all.\r\n    if (isInConcurrentTaskContext()) {\r\n      const currentTask = getCurrentTask()!;\r\n      coalescingScopes.set(cdRef, currentTask);\r\n      cdRef.detectChanges();\r\n      (currentTask.internalOnExecutedListeners ??= []).push(function() {\r\n        coalescingScopes.delete(cdRef);\r\n      });\r\n    } else {\r\n      cdRef.detectChanges();\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","import { IterableChangeRecord, NgIterable, TrackByFunction } from \"@angular/core\";\r\nimport { getTypeName, QueuexIterableChangeOperationHandler, QueuexIterableChanges, QueuexIterableDiffer, QueuexIterableDifferFactory } from \"./iterable_differs\";\r\n\r\nconst trackByIdentity = (_: number, item: any) => item;\r\n\r\nfunction iterateListLike<T>(obj: Iterable<T>, fn: (p: T) => void) {\r\n  if (Array.isArray(obj)) {\r\n    for (let i = 0; i < obj.length; i++) {\r\n      fn(obj[i]);\r\n    }\r\n  } else {\r\n    const iterator = obj[Symbol.iterator]();\r\n    let item: IteratorResult<T, any>;\r\n    while (!(item = iterator.next()).done) {\r\n      fn(item.value);\r\n    }\r\n  }\r\n}\r\n\r\nexport class DefaultQueuexIterableDifferFactory implements QueuexIterableDifferFactory {\r\n  supports(collection: any): boolean {\r\n    return isListLikeIterable(collection)\r\n  }\r\n  create<T>(trackByFn?: TrackByFunction<T> | null | undefined): QueuexIterableDiffer<T> {\r\n    trackByFn = trackByFn ?? trackByIdentity;\r\n    return new DefaultQueuexIterableDiffer(trackByFn);\r\n  }\r\n}\r\n\r\nexport class DefaultQueuexIterableDiffer<T> implements QueuexIterableDiffer<T>, QueuexIterableChanges<T> {\r\n  public readonly length: number = 0;\r\n  // Keeps track of the used records at any point in time (during & across `_check()` calls)\r\n  private _linkedRecords: _DuplicateMap<T>|null = null;\r\n  // Keeps track of the removed records at any point in time during `_check()` calls.\r\n  private _unlinkedRecords: _DuplicateMap<T>|null = null;\r\n  // private _previousItHead: IterableChangeRecord_<T>|null = null;\r\n  private _itHead: IterableChangeRecord_<T>|null = null;\r\n  private _itTail: IterableChangeRecord_<T>|null = null;\r\n  private _additionsHead: IterableChangeRecord_<T>|null = null;\r\n  private _additionsTail: IterableChangeRecord_<T>|null = null;\r\n  private _movesHead: IterableChangeRecord_<T>|null = null;\r\n  private _movesTail: IterableChangeRecord_<T>|null = null;\r\n  private _removalsHead: IterableChangeRecord_<T>|null = null;\r\n  private _removalsTail: IterableChangeRecord_<T>|null = null;\r\n  // Keeps track of records where custom track by is the same, but item identity has changed\r\n  private _identityChangesHead: IterableChangeRecord_<T>|null = null;\r\n  private _identityChangesTail: IterableChangeRecord_<T>|null = null;\r\n\r\n\r\n  constructor(private _trackByFn: TrackByFunction<T>) {}\r\n\r\n  applyOperations(handler: QueuexIterableChangeOperationHandler<T>): void {\r\n    let nextIt = this._itHead;\r\n    let nextRemove = this._removalsHead;\r\n    let addRemoveOffset = 0;\r\n    let moveOffsets: number[]|null = null;\r\n    while (nextIt || nextRemove) {\r\n      // Figure out which is the next record to process\r\n      // Order: remove, add, move\r\n      const record: IterableChangeRecord_<T> = !nextRemove ||\r\n              nextIt &&\r\n                  nextIt.currentIndex! <\r\n                      getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ?\r\n          nextIt! :\r\n          nextRemove;\r\n      const adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets);\r\n      const currentIndex = record.currentIndex;\r\n\r\n      // consume the item, and adjust the addRemoveOffset and update moveDistance if necessary\r\n      if (record === nextRemove) {\r\n        addRemoveOffset--;\r\n        nextRemove = nextRemove._nextRemoved;\r\n      } else {\r\n        nextIt = nextIt!._next;\r\n        if (record.previousIndex == null) {\r\n          addRemoveOffset++;\r\n        } else {\r\n          // INVARIANT:  currentIndex < previousIndex\r\n          if (!moveOffsets) moveOffsets = [];\r\n          const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset;\r\n          const localCurrentIndex = currentIndex! - addRemoveOffset;\r\n          if (localMovePreviousIndex != localCurrentIndex) {\r\n            for (let i = 0; i < localMovePreviousIndex; i++) {\r\n              const offset = i < moveOffsets.length ? moveOffsets[i] : (moveOffsets[i] = 0);\r\n              const index = offset + i;\r\n              if (localCurrentIndex <= index && index < localMovePreviousIndex) {\r\n                moveOffsets[i] = offset + 1;\r\n              }\r\n            }\r\n            const previousIndex = record.previousIndex;\r\n            moveOffsets[previousIndex] = localCurrentIndex - localMovePreviousIndex;\r\n          }\r\n        }\r\n      }\r\n\r\n      if (adjPreviousIndex !== currentIndex) {\r\n        if (record.previousIndex == null) {\r\n          handler.add(record as any);\r\n        } else if (currentIndex == null) {\r\n          handler.remove(record as any, adjPreviousIndex);\r\n        } else if (adjPreviousIndex !== null) {\r\n          handler.move(record as any, adjPreviousIndex, record._isIdentityChange);\r\n        }\r\n      } else {\r\n        handler.noop(record as any, record._isIdentityChange);\r\n      }\r\n    }\r\n    handler.done();\r\n  }\r\n\r\n  diff(collection: NgIterable<T> | null | undefined): QueuexIterableChanges<T> | null {\r\n    if (collection == null) collection = [];\r\n    if (!isListLikeIterable(collection)) {\r\n      throw new Error(`Error trying to diff '${collection}' of type '${getTypeName(collection)}'. Only arrays and iterables are allowed.`);\r\n    }\r\n\r\n    if (this._check(collection)) {\r\n      return this;\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private _check(collection: NgIterable<T>): boolean {\r\n    this._reset();\r\n\r\n    let record: IterableChangeRecord_<T> | null = this._itHead;\r\n    let mayBeDirty: boolean = false;\r\n    let index: number;\r\n    let item: T;\r\n    let itemTrackBy: any;\r\n    if (Array.isArray(collection)) {\r\n      (this as { length: number }).length = collection.length;\r\n\r\n      for (let index = 0; index < this.length; index++) {\r\n        item = collection[index];\r\n        itemTrackBy = this._trackByFn(index, item);\r\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\r\n          record = this._mismatch(record, item, itemTrackBy, index);\r\n          mayBeDirty = true;\r\n        } else {\r\n          if (mayBeDirty) {\r\n            // TODO(misko): can we limit this to duplicates only?\r\n            record = this._verifyReinsertion(record, itemTrackBy, index);\r\n          }\r\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\r\n        }\r\n\r\n        record = record._next;\r\n      }\r\n    } else {\r\n      index = 0;\r\n      iterateListLike(collection, (item: T) => {\r\n        itemTrackBy = this._trackByFn(index, item);\r\n        if (record === null || !Object.is(record.trackById, itemTrackBy)) {\r\n          record = this._mismatch(record, item, itemTrackBy, index);\r\n          mayBeDirty = true;\r\n        } else {\r\n          if (mayBeDirty) {\r\n            // TODO(misko): can we limit this to duplicates only?\r\n            record = this._verifyReinsertion(record, itemTrackBy, index);\r\n          }\r\n          if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\r\n        }\r\n        record = record._next;\r\n        index++;\r\n      });\r\n      (this as { length: number }).length = index;\r\n    }\r\n\r\n    this._truncate(record);\r\n\r\n    return this._isDirty();\r\n  }\r\n\r\n  /* CollectionChanges is considered dirty if it has any additions, moves, removals, or identity\r\n   * changes.\r\n   */\r\n  private _isDirty(): boolean {\r\n    return !(this._removalsHead === null && this._additionsHead === null &&\r\n        this._movesHead === null && this._identityChangesHead === null);\r\n  }\r\n\r\n  private _reset() {\r\n    if (this._isDirty()) {\r\n      let record: IterableChangeRecord_<T> | null;\r\n\r\n      // for (record = this._previousItHead = this._itHead; record !== null; record = record._next) {\r\n      //   record._nextPrevious = record._next;\r\n      // }\r\n\r\n      for (record = this._additionsHead; record !== null; record = record._nextAdded) {\r\n        record.previousIndex = record.currentIndex;\r\n      }\r\n      this._additionsHead = this._additionsTail = null;\r\n\r\n      for (record = this._movesHead; record !== null; record = record._nextMoved) {\r\n        record.previousIndex = record.currentIndex;\r\n      }\r\n      for (record = this._identityChangesHead; record !== null; record = record._nextIdentityChange) {\r\n        record._isIdentityChange = false;\r\n      }\r\n      this._movesHead = this._movesTail = null;\r\n      this._removalsHead = this._removalsTail = null;\r\n      this._identityChangesHead = this._identityChangesTail = null;\r\n\r\n      // TODO(vicb): when assert gets supported\r\n      // assert(!this.isDirty);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is the core function which handles differences between collections.\r\n   *\r\n   * - `record` is the record which we saw at this position last time. If null then it is a new\r\n   *   item.\r\n   * - `item` is the current item in the collection\r\n   * - `index` is the position of the item in the collection\r\n   */\r\n  private _mismatch(\r\n    record: IterableChangeRecord_<T> | null,\r\n    item: T,\r\n    itemTrackBy: any,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    // The previous record after which we will append the current one.\r\n    let previousRecord: IterableChangeRecord_<T> | null;\r\n\r\n    if (record === null) {\r\n      previousRecord = this._itTail;\r\n    } else {\r\n      previousRecord = record._prev;\r\n      // Remove the record from the collection since we know it does not match the item.\r\n      this._remove(record);\r\n    }\r\n\r\n    // See if we have evicted the item, which used to be at some anterior position of _itHead list.\r\n    record = this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\r\n    if (record !== null) {\r\n      // It is an item which we have evicted earlier: reinsert it back into the list.\r\n      // But first we need to check if identity changed, so we can update in view if necessary.\r\n      if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\r\n\r\n      this._reinsertAfter(record, previousRecord, index);\r\n    } else {\r\n      // Attempt to see if the item is at some posterior position of _itHead list.\r\n      record = this._linkedRecords === null ? null : this._linkedRecords.get(itemTrackBy, index);\r\n      if (record !== null) {\r\n        // We have the item in _itHead at/after `index` position. We need to move it forward in the\r\n        // collection.\r\n        // But first we need to check if identity changed, so we can update in view if necessary.\r\n        if (!Object.is(record.item, item)) this._addIdentityChange(record, item);\r\n\r\n        this._moveAfter(record, previousRecord, index);\r\n      } else {\r\n        // It is a new item: add it.\r\n        record = this._addAfter(\r\n          new IterableChangeRecord_<T>(item, itemTrackBy),\r\n          previousRecord,\r\n          index,\r\n        );\r\n      }\r\n    }\r\n    return record;\r\n  }\r\n\r\n  /**\r\n   * This check is only needed if an array contains duplicates. (Short circuit of nothing dirty)\r\n   *\r\n   * Use case: `[a, a]` => `[b, a, a]`\r\n   *\r\n   * If we did not have this check then the insertion of `b` would:\r\n   *   1) evict first `a`\r\n   *   2) insert `b` at `0` index.\r\n   *   3) leave `a` at index `1` as is. <-- this is wrong!\r\n   *   3) reinsert `a` at index 2. <-- this is wrong!\r\n   *\r\n   * The correct behavior is:\r\n   *   1) evict first `a`\r\n   *   2) insert `b` at `0` index.\r\n   *   3) reinsert `a` at index 1.\r\n   *   3) move `a` at from `1` to `2`.\r\n   *\r\n   *\r\n   * Double check that we have not evicted a duplicate item. We need to check if the item type may\r\n   * have already been removed:\r\n   * The insertion of b will evict the first 'a'. If we don't reinsert it now it will be reinserted\r\n   * at the end. Which will show up as the two 'a's switching position. This is incorrect, since a\r\n   * better way to think of it is as insert of 'b' rather then switch 'a' with 'b' and then add 'a'\r\n   * at the end.\r\n   *\r\n   * @internal\r\n   */\r\n  private _verifyReinsertion(\r\n    record: IterableChangeRecord_<T>,\r\n    // item: T,\r\n    itemTrackBy: any,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    let reinsertRecord: IterableChangeRecord_<T> | null =\r\n      this._unlinkedRecords === null ? null : this._unlinkedRecords.get(itemTrackBy, null);\r\n    if (reinsertRecord !== null) {\r\n      record = this._reinsertAfter(reinsertRecord, record._prev!, index);\r\n    } else if (record.currentIndex != index) {\r\n      record.currentIndex = index;\r\n      this._addToMoves(record, index);\r\n    }\r\n    return record;\r\n  }\r\n\r\n  /**\r\n   * Get rid of any excess {@link IterableChangeRecord_}s from the previous collection\r\n   *\r\n   * - `record` The first excess {@link IterableChangeRecord_}.\r\n   *\r\n   */\r\n  private _truncate(record: IterableChangeRecord_<T> | null) {\r\n    // Anything after that needs to be removed;\r\n    while (record !== null) {\r\n      const nextRecord: IterableChangeRecord_<T> | null = record._next;\r\n      this._addToRemovals(this._unlink(record));\r\n      record = nextRecord;\r\n    }\r\n    if (this._unlinkedRecords !== null) {\r\n      this._unlinkedRecords.clear();\r\n    }\r\n\r\n    if (this._additionsTail !== null) {\r\n      this._additionsTail._nextAdded = null;\r\n    }\r\n    if (this._movesTail !== null) {\r\n      this._movesTail._nextMoved = null;\r\n    }\r\n    if (this._itTail !== null) {\r\n      this._itTail._next = null;\r\n    }\r\n    if (this._removalsTail !== null) {\r\n      this._removalsTail._nextRemoved = null;\r\n    }\r\n    if (this._identityChangesTail !== null) {\r\n      this._identityChangesTail._nextIdentityChange = null;\r\n    }\r\n  }\r\n\r\n  private _reinsertAfter(\r\n    record: IterableChangeRecord_<T>,\r\n    prevRecord: IterableChangeRecord_<T> | null,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    if (this._unlinkedRecords !== null) {\r\n      this._unlinkedRecords.remove(record);\r\n    }\r\n    const prev = record._prevRemoved;\r\n    const next = record._nextRemoved;\r\n\r\n    if (prev === null) {\r\n      this._removalsHead = next;\r\n    } else {\r\n      prev._nextRemoved = next;\r\n    }\r\n    if (next === null) {\r\n      this._removalsTail = prev;\r\n    } else {\r\n      next._prevRemoved = prev;\r\n    }\r\n\r\n    this._insertAfter(record, prevRecord, index);\r\n    this._addToMoves(record, index);\r\n    return record;\r\n  }\r\n\r\n  private _moveAfter(\r\n    record: IterableChangeRecord_<T>,\r\n    prevRecord: IterableChangeRecord_<T> | null,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    this._unlink(record);\r\n    this._insertAfter(record, prevRecord, index);\r\n    this._addToMoves(record, index);\r\n    return record;\r\n  }\r\n\r\n  private _addAfter(\r\n    record: IterableChangeRecord_<T>,\r\n    prevRecord: IterableChangeRecord_<T> | null,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    this._insertAfter(record, prevRecord, index);\r\n\r\n    if (this._additionsTail === null) {\r\n      // TODO(vicb):\r\n      // assert(this._additionsHead === null);\r\n      this._additionsTail = this._additionsHead = record;\r\n    } else {\r\n      // TODO(vicb):\r\n      // assert(_additionsTail._nextAdded === null);\r\n      // assert(record._nextAdded === null);\r\n      this._additionsTail = this._additionsTail._nextAdded = record;\r\n    }\r\n    return record;\r\n  }\r\n\r\n  private _insertAfter(\r\n    record: IterableChangeRecord_<T>,\r\n    prevRecord: IterableChangeRecord_<T> | null,\r\n    index: number,\r\n  ): IterableChangeRecord_<T> {\r\n    // TODO(vicb):\r\n    // assert(record != prevRecord);\r\n    // assert(record._next === null);\r\n    // assert(record._prev === null);\r\n\r\n    const next: IterableChangeRecord_<T> | null =\r\n      prevRecord === null ? this._itHead : prevRecord._next;\r\n    // TODO(vicb):\r\n    // assert(next != record);\r\n    // assert(prevRecord != record);\r\n    record._next = next;\r\n    record._prev = prevRecord;\r\n    if (next === null) {\r\n      this._itTail = record;\r\n    } else {\r\n      next._prev = record;\r\n    }\r\n    if (prevRecord === null) {\r\n      this._itHead = record;\r\n    } else {\r\n      prevRecord._next = record;\r\n    }\r\n\r\n    if (this._linkedRecords === null) {\r\n      this._linkedRecords = new _DuplicateMap<T>();\r\n    }\r\n    this._linkedRecords.put(record);\r\n\r\n    record.currentIndex = index;\r\n    return record;\r\n  }\r\n\r\n\r\n  private _remove(record: IterableChangeRecord_<T>): IterableChangeRecord_<T> {\r\n    return this._addToRemovals(this._unlink(record));\r\n  }\r\n\r\n\r\n  private _unlink(record: IterableChangeRecord_<T>): IterableChangeRecord_<T> {\r\n    if (this._linkedRecords !== null) {\r\n      this._linkedRecords.remove(record);\r\n    }\r\n\r\n    const prev = record._prev;\r\n    const next = record._next;\r\n\r\n    // TODO(vicb):\r\n    // assert((record._prev = null) === null);\r\n    // assert((record._next = null) === null);\r\n\r\n    if (prev === null) {\r\n      this._itHead = next;\r\n    } else {\r\n      prev._next = next;\r\n    }\r\n    if (next === null) {\r\n      this._itTail = prev;\r\n    } else {\r\n      next._prev = prev;\r\n    }\r\n\r\n    return record;\r\n  }\r\n\r\n\r\n  private  _addToMoves(record: IterableChangeRecord_<T>, toIndex: number): IterableChangeRecord_<T> {\r\n    // TODO(vicb):\r\n    // assert(record._nextMoved === null);\r\n\r\n    if (record.previousIndex === toIndex) {\r\n      return record;\r\n    }\r\n\r\n    if (this._movesTail === null) {\r\n      // TODO(vicb):\r\n      // assert(_movesHead === null);\r\n      this._movesTail = this._movesHead = record;\r\n    } else {\r\n      // TODO(vicb):\r\n      // assert(_movesTail._nextMoved === null);\r\n      this._movesTail = this._movesTail._nextMoved = record;\r\n    }\r\n\r\n    return record;\r\n  }\r\n\r\n  private _addToRemovals(record: IterableChangeRecord_<T>): IterableChangeRecord_<T> {\r\n    if (this._unlinkedRecords === null) {\r\n      this._unlinkedRecords = new _DuplicateMap<T>();\r\n    }\r\n    this._unlinkedRecords.put(record);\r\n    record.currentIndex = null;\r\n    record._nextRemoved = null;\r\n\r\n    if (this._removalsTail === null) {\r\n      // TODO(vicb):\r\n      // assert(_removalsHead === null);\r\n      this._removalsTail = this._removalsHead = record;\r\n      record._prevRemoved = null;\r\n    } else {\r\n      // TODO(vicb):\r\n      // assert(_removalsTail._nextRemoved === null);\r\n      // assert(record._nextRemoved === null);\r\n      record._prevRemoved = this._removalsTail;\r\n      this._removalsTail = this._removalsTail._nextRemoved = record;\r\n    }\r\n    return record;\r\n  }\r\n\r\n\r\n  private _addIdentityChange(record: IterableChangeRecord_<T>, item: T) {\r\n    record.item = item;\r\n    record._isIdentityChange = true\r\n    if (this._identityChangesTail === null) {\r\n      this._identityChangesTail = this._identityChangesHead = record;\r\n    } else {\r\n      this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record;\r\n    }\r\n    return record;\r\n  }\r\n}\r\n\r\nclass _DuplicateItemRecordList<T> {\r\n  /** @internal */\r\n  _head: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _tail: IterableChangeRecord_<T>|null = null;\r\n\r\n  /**\r\n   * Append the record to the list of duplicates.\r\n   *\r\n   * Note: by design all records in the list of duplicates hold the same value in record.item.\r\n   */\r\n  add(record: IterableChangeRecord_<T>): void {\r\n    if (this._head === null) {\r\n      this._head = this._tail = record;\r\n      record._nextDup = null;\r\n      record._prevDup = null;\r\n    } else {\r\n      // TODO(vicb):\r\n      // assert(record.item ==  _head.item ||\r\n      //       record.item is num && record.item.isNaN && _head.item is num && _head.item.isNaN);\r\n      this._tail!._nextDup = record;\r\n      record._prevDup = this._tail;\r\n      record._nextDup = null;\r\n      this._tail = record;\r\n    }\r\n  }\r\n\r\n  // Returns a IterableChangeRecord_ having IterableChangeRecord_.trackById == trackById and\r\n  // IterableChangeRecord_.currentIndex >= atOrAfterIndex\r\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<T>|null {\r\n    let record: IterableChangeRecord_<T>|null;\r\n    for (record = this._head; record !== null; record = record._nextDup) {\r\n      if ((atOrAfterIndex === null || atOrAfterIndex <= record.currentIndex!) &&\r\n          Object.is(record.trackById, trackById)) {\r\n        return record;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Remove one {@link IterableChangeRecord_} from the list of duplicates.\r\n   *\r\n   * Returns whether the list of duplicates is empty.\r\n   */\r\n  remove(record: IterableChangeRecord_<T>): boolean {\r\n\r\n    const prev: IterableChangeRecord_<T>|null = record._prevDup;\r\n    const next: IterableChangeRecord_<T>|null = record._nextDup;\r\n    if (prev === null) {\r\n      this._head = next;\r\n    } else {\r\n      prev._nextDup = next;\r\n    }\r\n    if (next === null) {\r\n      this._tail = prev;\r\n    } else {\r\n      next._prevDup = prev;\r\n    }\r\n    return this._head === null;\r\n  }\r\n}\r\n\r\nclass _DuplicateMap<T> {\r\n  map = new Map<any, _DuplicateItemRecordList<T>>();\r\n\r\n  put(record: IterableChangeRecord_<T>) {\r\n    const key = record.trackById;\r\n\r\n    let duplicates = this.map.get(key);\r\n    if (!duplicates) {\r\n      duplicates = new _DuplicateItemRecordList<T>();\r\n      this.map.set(key, duplicates);\r\n    }\r\n    duplicates.add(record);\r\n  }\r\n\r\n  /**\r\n   * Retrieve the `value` using key. Because the IterableChangeRecord_ value may be one which we\r\n   * have already iterated over, we use the `atOrAfterIndex` to pretend it is not there.\r\n   *\r\n   * Use case: `[a, b, c, a, a]` if we are at index `3` which is the second `a` then asking if we\r\n   * have any more `a`s needs to return the second `a`.\r\n   */\r\n  get(trackById: any, atOrAfterIndex: number|null): IterableChangeRecord_<T>|null {\r\n    const key = trackById;\r\n    const recordList = this.map.get(key);\r\n    return recordList ? recordList.get(trackById, atOrAfterIndex) : null;\r\n  }\r\n\r\n  /**\r\n   * Removes a {@link IterableChangeRecord_} from the list of duplicates.\r\n   *\r\n   * The list of duplicates also is removed from the map if it gets empty.\r\n   */\r\n  remove(record: IterableChangeRecord_<T>): IterableChangeRecord_<T> {\r\n    const key = record.trackById;\r\n    const recordList: _DuplicateItemRecordList<T> = this.map.get(key)!;\r\n    // Remove the list of duplicates when it gets empty\r\n    if (recordList.remove(record)) {\r\n      this.map.delete(key);\r\n    }\r\n    return record;\r\n  }\r\n\r\n  get isEmpty(): boolean {\r\n    return this.map.size === 0;\r\n  }\r\n\r\n  clear() {\r\n    this.map.clear();\r\n  }\r\n}\r\n\r\n\r\nclass IterableChangeRecord_<T> implements IterableChangeRecord<T> {\r\n  currentIndex: number|null = null;\r\n  previousIndex: number|null = null;\r\n\r\n  /** @internal */\r\n  _nextPrevious: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _prev: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _next: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _prevDup: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _nextDup: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _prevRemoved: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _nextRemoved: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _nextAdded: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _nextMoved: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _nextIdentityChange: IterableChangeRecord_<T>|null = null;\r\n  /** @internal */\r\n  _isIdentityChange = false\r\n\r\n\r\n  constructor(public item: T, public trackById: any) {}\r\n}\r\n\r\nfunction getPreviousIndex(item: any, addRemoveOffset: number, moveOffsets: number[]|null): number {\r\n  const previousIndex = item.previousIndex;\r\n  if (previousIndex === null) return previousIndex;\r\n  let moveOffset = 0;\r\n  if (moveOffsets && previousIndex < moveOffsets.length) {\r\n    moveOffset = moveOffsets[previousIndex];\r\n  }\r\n  return previousIndex + addRemoveOffset + moveOffset;\r\n}\r\n\r\nfunction isListLikeIterable(obj: any): boolean {\r\n  if (!isJsObject(obj)) return false;\r\n  return Array.isArray(obj) ||\r\n      (!(obj instanceof Map) &&  // JS Map are iterables but return entries as [k, v]\r\n       Symbol.iterator in obj);  // JS Iterable have a Symbol.iterator prop\r\n}\r\n\r\nexport function isJsObject(o: any): boolean {\r\n  return o !== null && (typeof o === 'function' || typeof o === 'object');\r\n}\r\n","import { inject, Injectable, IterableChangeRecord, NgIterable, StaticProvider, TrackByFunction } from \"@angular/core\";\r\nimport { DefaultQueuexIterableDifferFactory } from \"./default_iterable_differ\";\r\n\r\nexport type StillPresentIterableChangeRecord<T> = IterableChangeRecord<T> & { readonly previousIndex: number; readonly currentIndex: number };\r\nexport type RemovedIterableChangeRecord<T> = IterableChangeRecord<T> & { readonly previousIndex: number; readonly currentIndex: null };\r\nexport type AddedIterableChangeRecord<T> = IterableChangeRecord<T> & { readonly previousIndex: null; readonly currentIndex: number };\r\n\r\n/**\r\n * A strategy for tracking changes over time to an iterable.\r\n */\r\nexport interface QueuexIterableDiffer<T> {\r\n  /**\r\n   * Compute a difference between the previous state and the new `object` state.\r\n   *\r\n   * @param object containing the new value.\r\n   * @returns an object describing the difference. The return value is only valid until the next\r\n   * `diff()` invocation.\r\n   */\r\n  diff(object: NgIterable<T> | undefined | null): QueuexIterableChanges<T> | null;\r\n}\r\n\r\n/**\r\n * An object describing the changes in the `Iterable` collection since last time\r\n * `QueuexIterableDiffer#diff()` was invoked.\r\n */\r\nexport interface QueuexIterableChanges<T> {\r\n\r\n  /**\r\n   * Provide changes to handler by iterating through all records (`IterableChangeRecord`).\r\n   * @param handler An object that handles changes.\r\n   * @see {@link IterableChangeRecord}\r\n   */\r\n  applyOperations(handler: QueuexIterableChangeOperationHandler<T>): void;\r\n\r\n  /**\r\n   * A current state collection length, reflecting items count.\r\n   */\r\n  readonly length: number;\r\n}\r\n\r\n/**\r\n * A strategy for handling collection changes.\r\n */\r\nexport interface QueuexIterableChangeOperationHandler<T> {\r\n  /**\r\n   * Handles a new added item.\r\n   * @param record Added record.\r\n   */\r\n  add(record: AddedIterableChangeRecord<T>): void;\r\n\r\n  /**\r\n   * Handles a removed item.\r\n   * @param record Removed record\r\n   * @param adjustedIndex Position from where item should be removed, adjusted to current changing state during iteration.\r\n   */\r\n  remove(record: RemovedIterableChangeRecord<T>, adjustedIndex: number): void;\r\n\r\n  /**\r\n   * Handles a moved item.\r\n   * @param record Moved record.\r\n   * @param adjustedPreviousIndex A previous position of item, adjusted to current changing state during iteration.\r\n   * @param changed True if identity has changed, otherwise false.\r\n   */\r\n  move(record: StillPresentIterableChangeRecord<T>, adjustedPreviousIndex: number, changed: boolean): void;\r\n\r\n  /**\r\n   * It is invoked for item where you should not do changes to target state during iteration. To illustrate that, lets\r\n   * consider an array ['a', 'b', 'c] where 'b' was removed. There are two changes:\r\n   *  1) 'b' is removed,\r\n   *  2) 'c' moved from index 2 to 1.\r\n   * During change providing , when on target array you remove second element, third one will already change position,\r\n   * so there is no need to made that change. However if target state relies on current item position, this hook can provide that handling.\r\n   * @param record Unchanged record.\r\n   * @param changed True if identity has changed, otherwise false.\r\n   */\r\n  noop(record: StillPresentIterableChangeRecord<T>, changed: boolean): void;\r\n\r\n  /**\r\n   * This callback is called when iteration is finished.\r\n   */\r\n  done(): void;\r\n}\r\n\r\n\r\nexport interface QueuexIterableDifferFactory {\r\n  supports(object: any): boolean;\r\n  create<T>(trackByFn: TrackByFunction<T>): QueuexIterableDiffer<T>\r\n}\r\n\r\n/**\r\n * A repository of different iterable diffing strategies.\r\n */\r\n@Injectable({ providedIn: 'root', useFactory: () => new QueuexIterableDiffers([new DefaultQueuexIterableDifferFactory]) })\r\nexport class QueuexIterableDiffers {\r\n\r\n  constructor(private _factories: QueuexIterableDifferFactory[]) {}\r\n\r\n  find(iterable: any): QueuexIterableDifferFactory {\r\n    const factory = this._factories.find((f) => f.supports(iterable));\r\n    if (factory) {\r\n      return factory;\r\n    } else {\r\n      throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${getTypeName(iterable)}'!`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Takes an array of {@link QueuexIterableDifferFactory} and returns a provider used to extend the\r\n   * inherited {@link QueuexIterableDiffers} instance with the provided factories and return a new\r\n   * {@link QueuexIterableDiffers} instance.\r\n   *\r\n   * @usageNotes\r\n   * ### Example\r\n   *\r\n   * The following example shows how to extend an existing list of factories,\r\n   * which will only be applied to the injector for this component and its children.\r\n   * This step is all that's required to make a new {@link QueuexIterableDiffer} available.\r\n   *\r\n   * ```ts\r\n   * @Component({\r\n   *   viewProviders: [\r\n   *     QueuexIterableDiffers.extend([new ImmutableListDiffer()])\r\n   *   ]\r\n   * })\r\n   * ```\r\n   */\r\n  static extend(factories: QueuexIterableDifferFactory[]): StaticProvider {\r\n    return {\r\n      provide: QueuexIterableDiffers,\r\n      useFactory: () => {\r\n        const parent = inject(QueuexIterableDiffers, { optional: true, skipSelf: true });\r\n        // if parent is null, it means that we are in the root injector and we have just overridden\r\n        // the default injection mechanism for QueuexIterableDiffers.\r\n        return QueuexIterableDiffers._create(factories, parent || new QueuexIterableDiffers([new DefaultQueuexIterableDifferFactory()]))\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _create(factories: QueuexIterableDifferFactory[], parent?: QueuexIterableDiffers): QueuexIterableDiffers {\r\n    if (parent != null) {\r\n      factories = factories.concat(parent._factories);\r\n    }\r\n    return new QueuexIterableDiffers(factories);\r\n  }\r\n}\r\n\r\nexport function getTypeName(arg: any): string {\r\n  if (typeof arg === 'object' || typeof arg === 'function') {\r\n    return arg.constructor.name;\r\n  }\r\n  return typeof arg;\r\n}\r\n","import { computed, isSignal, signal, Signal, WritableSignal } from \"@angular/core\";\r\nimport { NG_DEV_MODE } from \"../utils\";\r\n\r\n\r\n/**\r\n * Represents a reference to a shared signal.\r\n *\r\n * Provides access to the underlying signal (`ref`)\r\n * and a method (`set`) to update its value directly or\r\n * by linking it to another signal.\r\n *\r\n */\r\nexport interface SharedSignalRef<T> {\r\n\r\n   /**\r\n   * The underlying signal reference.\r\n   */\r\n  readonly ref: Signal<T>\r\n\r\n   /**\r\n   * Updates the signal value.\r\n   *\r\n   * If a plain value is provided, the signal is set directly.\r\n   * If another signal is provided, the reference will follow that signal.\r\n   *\r\n   * @param value A new value or another signal to bind.\r\n   */\r\n  set<T>(value: T | Signal<T>): void\r\n}\r\n\r\ninterface InternalSharedSignalRef<T> extends SharedSignalRef<T> {\r\n  __internalSource__: WritableSignal<any>;\r\n  __externalSource__: Signal<T> | null\r\n}\r\n\r\n/**\r\n * Creates a shared signal reference.\r\n *\r\n * A shared signal allows you to either wrap a plain value into a signal\r\n * or forward another signal reference. The returned object provides\r\n * access to the underlying signal (`ref`) and a `set` method for updating\r\n * its value or re-linking it to a different signal.\r\n *\r\n *\r\n * @param initialValue The initial value of the signal, or another signal to bind.\r\n * @param debugName Optional developer-friendly label for debugging purposes.\r\n *\r\n * @returns A {@link SharedSignalRef} object containing the signal reference and mutation API.\r\n *\r\n * @example\r\n * ```ts\r\n * const count = sharedSignal(0, 'counter');\r\n * count.set(1);\r\n * console.log(count.ref()); // 1\r\n *\r\n * const source = signal(42);\r\n * count.set(source);\r\n * console.log(count.ref()); // 42\r\n * ```\r\n */\r\nexport function sharedSignal<T>(initialValue: T | Signal<T>, debugName?: string): SharedSignalRef<T> {\r\n  const internalSource = signal<any>(initialValue)\r\n  const externalSource = isSignal(initialValue) ? initialValue : null;\r\n  const signalRef: InternalSharedSignalRef<T> = {\r\n    __internalSource__: internalSource,\r\n    __externalSource__: externalSource,\r\n    set(value) {\r\n      if (isSignal(value)) {\r\n        this.__externalSource__ = value as any\r\n      } else {\r\n        this.__externalSource__ = null;\r\n      }\r\n      this.__internalSource__.set(value);\r\n    },\r\n    ref: null!\r\n  }\r\n\r\n  const compotation: () => T = (function (this: InternalSharedSignalRef<T>) {\r\n    const result = this.__internalSource__();\r\n    if (this.__externalSource__) {\r\n      return this.__externalSource__();\r\n    }\r\n    return result;\r\n  }).bind(signalRef);\r\n\r\n  const options = typeof debugName === 'string' ? { debugName } : undefined\r\n\r\n  Object.defineProperty(signalRef, 'ref', {\r\n    value: computed(compotation, options),\r\n    writable: false\r\n  });\r\n\r\n  if (NG_DEV_MODE) {\r\n    (signalRef as any).toString = () => `[SharedSignalRef.ref: ${signalRef.ref}]`;\r\n    if (typeof debugName === 'string') {\r\n      (signalRef as any).debugName = debugName;\r\n    } else {\r\n      (signalRef as any).debugName = 'SharedSignalRef';\r\n    }\r\n  }\r\n\r\n  return signalRef;\r\n}\r\n","import { assertInInjectionContext, assertNotInReactiveContext, DestroyRef, inject, isSignal, Signal } from \"@angular/core\";\r\nimport { ReactiveHookFn, ReactiveNode, createWatch, setPostSignalSetFn, setActiveConsumer, Watch } from \"@angular/core/primitives/signals\";\r\nimport { NG_DEV_MODE } from \"../utils\";\r\n\r\n/**\r\n * Represents reference to value directly provided by `set` method or\r\n * to the most recent value of provided signal. In case of signal, it allows safely\r\n * access to recent value in notification faze without touching internal signal node.\r\n */\r\nexport interface ValueRef<T> {\r\n\r\n  /**\r\n   * The underlying value.\r\n   */\r\n  readonly value: T\r\n\r\n  /**\r\n   * Updates the value.\r\n   *\r\n   * If plain value is provided, directly sets the underlying value.\r\n   * If signal is provided, reference will fallow that signal.\r\n   *\r\n   * @param value A new value or signal to observe and extracts values in synchronic way.\r\n   */\r\n  set(value: T | Signal<T>): void\r\n}\r\n\r\ninterface InternalValueRef<T> extends ValueRef<T> {\r\n  __watcher__: Watch | null;\r\n  __value__: T;\r\n}\r\n\r\nconst BASE_VALUE_REF = {\r\n  set(this: InternalValueRef<any>, value: any | Signal<any>) {\r\n    if (this.__watcher__) { this.__watcher__.destroy(); }\r\n    if (isSignal(value)) {\r\n      this.__watcher__ = watchSignal(value, (v) => this.__value__ = v);\r\n      return;\r\n    }\r\n    this.__value__ = value;\r\n  },\r\n  get value() {\r\n    return (this as any).__value__;\r\n  }\r\n}\r\n\r\nexport function watchSignal<T>(source: Signal<T>, callback: (arg: T) => void): Watch {\r\n  let prevHook: ReactiveHookFn | null = null;\r\n  let node: ReactiveNode | null = null;\r\n  const hook: ReactiveHookFn = (n) => {\r\n    node = n;\r\n    watcher.run();\r\n  }\r\n  const watcher = createWatch(\r\n    () => {\r\n      setPostSignalSetFn(prevHook);\r\n      if (prevHook) {\r\n        prevHook(node!);\r\n      }\r\n      const value = source();\r\n      const prevConsumer = setActiveConsumer(null);\r\n      try {\r\n        callback(value);\r\n      } finally {\r\n        setActiveConsumer(prevConsumer);\r\n      }\r\n    },\r\n    () => {\r\n      prevHook = setPostSignalSetFn(hook);\r\n    },\r\n    true\r\n  );\r\n  watcher.notify();\r\n  watcher.run();\r\n\r\n  return watcher;\r\n}\r\n\r\n/**\r\n * Creates a value reference.\r\n *\r\n * A `ValueRef` is a lightweight wrapper that always exposes\r\n * the most recent value of either:\r\n *   - a plain value of type `T`, or\r\n *   - a reactive `Signal<T>`.\r\n *\r\n * Unlike reading a signal directly, accessing `.value` on a `ValueRef`\r\n * is always safe — even during the signal notification phase, when\r\n * normal signal reads are disallowed. The reference never touches\r\n * the internal signal node and does not participate in dependency tracking.\r\n *\r\n * The `set()` method does not update the underlying signal. Instead,\r\n * it rebinds the `ValueRef` to a new value or to another signal.\r\n *\r\n * @param initialValue The initial value or signal to bind.\r\n * @throws Error if is used not in injection context.\r\n * @throws Error if is used in reactive context.\r\n */\r\nexport function value<T>(initialValue: T | Signal<T>): ValueRef<T>;\r\n/**\r\n * Creates a value reference.\r\n *\r\n * A `ValueRef` is a lightweight wrapper that always exposes\r\n * the most recent value of either:\r\n *   - a plain value of type `T`, or\r\n *   - a reactive `Signal<T>`.\r\n *\r\n * Unlike reading a signal directly, accessing `.value` on a `ValueRef`\r\n * is always safe — even during the signal notification phase, when\r\n * normal signal reads are disallowed. The reference never touches\r\n * the internal signal node and does not participate in dependency tracking.\r\n *\r\n * The `set()` method does not update the underlying signal. Instead,\r\n * it rebinds the `ValueRef` to a new value or to another signal.\r\n *\r\n * @param initialValue The initial value or signal to bind.\r\n * @param destroyRef The object that implements `DestroyRef` abstract class.\r\n * @throws Error if is used in reactive context.\r\n *\r\n * @see {@link DestroyRef}\r\n */\r\nexport function value<T>(initialValue: T | Signal<T>, destroyRef: DestroyRef): ValueRef<T>;\r\n/**\r\n * Creates a value reference.\r\n *\r\n * A `ValueRef` is a lightweight wrapper that always exposes\r\n * the most recent value of either:\r\n *   - a plain value of type `T`, or\r\n *   - a reactive `Signal<T>`.\r\n *\r\n * Unlike reading a signal directly, accessing `.value` on a `ValueRef`\r\n * is always safe — even during the signal notification phase, when\r\n * normal signal reads are disallowed. The reference never touches\r\n * the internal signal node and does not participate in dependency tracking.\r\n *\r\n * The `set()` method does not update the underlying signal. Instead,\r\n * it rebinds the `ValueRef` to a new value or to another signal.\r\n *\r\n * @param initialValue The initial value or signal to bind.\r\n * @param debugName Optional developer-friendly label for debugging purposes.\r\n * @throws Error if is used not in injection context.\r\n * @throws Error if is used in reactive context.\r\n */\r\nexport function value<T>(initialValue: T | Signal<T>, debugName: string | undefined): ValueRef<T>;\r\n/**\r\n * Creates a value reference.\r\n *\r\n * A `ValueRef` is a lightweight wrapper that always exposes\r\n * the most recent value of either:\r\n *   - a plain value of type `T`, or\r\n *   - a reactive `Signal<T>`.\r\n *\r\n * Unlike reading a signal directly, accessing `.value` on a `ValueRef`\r\n * is always safe — even during the signal notification phase, when\r\n * normal signal reads are disallowed. The reference never touches\r\n * the internal signal node and does not participate in dependency tracking.\r\n *\r\n * The `set()` method does not update the underlying signal. Instead,\r\n * it rebinds the `ValueRef` to a new value or to another signal.\r\n *\r\n * @param initialValue The initial value or signal to bind.\r\n * @param destroyRef The object that implements `DestroyRef` abstract class.\r\n * @param debugName Optional developer-friendly label for debugging purposes.\r\n * @throws Error if is used in reactive context.\r\n *\r\n * @see {@link DestroyRef}\r\n */\r\nexport function value<T>(initialValue: T | Signal<T>, destroyRef: DestroyRef, debugName: string | undefined): ValueRef<T>;\r\nexport function value<T>(initialValue: T | Signal<T>, arg2?: any, arg3?: any): ValueRef<T> {\r\n  (NG_DEV_MODE) &&\r\n    assertNotInReactiveContext(value);\r\n\r\n  let destroyRef: DestroyRef | null = null;\r\n  let debugName = 'ValueRef'\r\n\r\n  if (typeof arg2 === 'object' && typeof arg2.onDestroy === 'function' && typeof arg2.destroyed === 'boolean') {\r\n    destroyRef = arg2\r\n  }\r\n\r\n  if (typeof arg2 === 'string') { debugName = arg2; }\r\n  if (typeof arg3 === 'string') { debugName = arg3; }\r\n\r\n  if (!destroyRef) {\r\n    (NG_DEV_MODE) &&\r\n      assertInInjectionContext(value);\r\n    destroyRef = inject(DestroyRef);\r\n  }\r\n\r\n  const ref = Object.create(BASE_VALUE_REF) as InternalValueRef<T>;\r\n  ref.__value__ = undefined!;\r\n  ref.__watcher__ = null;\r\n  ref.set(initialValue);\r\n\r\n  if (NG_DEV_MODE) {\r\n    (ref as any).toString = () => `[ValueRef.value: ${ref.__value__}]`;\r\n    (ref as any).debugName = debugName;\r\n  }\r\n\r\n\r\n  destroyRef.onDestroy(() => {\r\n    if(ref.__watcher__) {\r\n      ref.__watcher__.destroy();\r\n    }\r\n  });\r\n\r\n  return ref;\r\n}\r\n","import { PriorityLevel, priorityNameToNumber, PriorityName } from './../scheduler/scheduler_utils';\r\nimport { assertInInjectionContext, assertNotInReactiveContext, DestroyRef, EffectCleanupRegisterFn, EffectRef, inject } from \"@angular/core\";\r\nimport { createWatch, Watch } from \"@angular/core/primitives/signals\";\r\nimport { scheduleTask } from \"../instructions/instructions\";\r\nimport { NG_DEV_MODE } from '../utils';\r\nimport { INTEGRATION_NOT_COMPLETED_MESSAGE, INTEGRATION_NOT_PROVIDED_MESSAGE, Integrator, SERVER_SIDE_MESSAGE } from '../environment/environment';\r\n\r\n/**\r\n * Options to configure a concurrent effect created via `concurrentEffect()`.\r\n *\r\n * @interface ConcurrentEffectOptions\r\n *\r\n * @property {PriorityName} [priority]\r\n * Optional priority level (e.g. 'highest' | 'high' | 'normal' | 'low' | 'lowest').\r\n * Determines how soon the scheduled task should be executed by the concurrent scheduler.\r\n * Default is 'normal'\r\n *\r\n * @property {boolean} [manualCleanup]\r\n * If `true`, the effect will not automatically register cleanups and must be cleaned up manually.\r\n *\r\n * @property {DestroyRef} [destroyRef]\r\n * Optional Angular `DestroyRef` to automatically dispose of the effect when the hosting context is destroyed.\r\n *\r\n * @property {boolean} [allowSignalWrites]\r\n * Allows writing to signals within the effect execution context.\r\n * Defaults to `false` for safety.\r\n */\r\nexport interface ConcurrentEffectOptions {\r\n\r\n  /**\r\n   * Optional priority level (e.g. 'highest' | 'high' | 'normal' | 'low' | 'lowest').\r\n   * Determines how soon the scheduled task should be executed by the concurrent scheduler.\r\n   * Default is 'normal'\r\n   */\r\n  priority?: PriorityName,\r\n\r\n  /**\r\n   * If `true`, the effect will not automatically register cleanups and must be cleaned up manually.\r\n   */\r\n  manualCleanup?: boolean,\r\n\r\n  /**\r\n   * Optional Angular `DestroyRef` to automatically dispose of the effect when the hosting context is destroyed.\r\n   */\r\n  destroyRef?: DestroyRef,\r\n\r\n  /**\r\n   * Allows writing to signals within the effect execution context.\r\n   * Defaults to `false` for safety.\r\n   */\r\n  allowSignalWrites?: boolean\r\n}\r\n\r\nclass EffectRefImpl implements EffectRef {\r\n  private _watcher: Watch;\r\n\r\n  constructor(\r\n    fn: (onCleanup: EffectCleanupRegisterFn) => void,\r\n    priorityLevel: PriorityLevel,\r\n    allowSignalWrites: boolean,\r\n  ) {\r\n    this._watcher = createWatch(\r\n      fn,\r\n      () => scheduleTask(() => this._watcher.run(), priorityLevel),\r\n      allowSignalWrites\r\n    );\r\n    this._watcher.notify();\r\n  }\r\n\r\n  destroy(): void {\r\n    this._watcher.destroy();\r\n  }\r\n}\r\n\r\n/**\r\n * Creates a concurrent effect — a reactive computation scheduled and coordinated\r\n * by the concurrent scheduler from `ng-queuex/core`.\r\n *\r\n * Unlike Angular’s built-in `effect()`, this variant introduces: **Priority-based scheduling** (`highest` → `lowest`),\r\n *\r\n * The effect body is executed through a `Watch` that is detached from Angular’s\r\n * change detection cycles. Its execution is triggered by the scheduler at the\r\n * configured priority level, ensuring deterministic and efficient updates.\r\n *\r\n * @param effectFn - Effect function to execute.\r\n *   Receives a cleanup registration callback `(onCleanup) => { ... }` used to register\r\n *   teardown logic (e.g. clearing timers, unsubscribing observables).\r\n *\r\n * @param options - (Optional) effect configuration:\r\n * - `priority`: Scheduler priority (`'highest' | 'high' | 'normal' | 'low' | 'lowest'`).\r\n *   Defaults to `'normal'`.\r\n * - `manualCleanup`: If `true`, the effect must be explicitly destroyed.\r\n *   Defaults to `false`.\r\n * - `destroyRef`: An Angular `DestroyRef` to hook automatic cleanup into.\r\n *   If omitted and `manualCleanup` is `false`, one will be injected.\r\n * - `allowSignalWrites`: Enables writes to signals inside the effect.\r\n *   Defaults to `false`.\r\n *\r\n * @returns {@link EffectRef} A reference handle that allows manual destruction\r\n * of the effect via `effectRef.destroy()`.\r\n *\r\n * @throws If is used in reactive context.\r\n * @throws `Error` if integration was not provided.\r\n * @throws `Error` if is server environment.\r\n * @throws `Error` if integration for unit test is not completed.\r\n *\r\n * @example\r\n * ```ts\r\n * const ref = concurrentEffect((onCleanup) => {\r\n *   const id = setInterval(() => console.log('tick'), 1000);\r\n *   onCleanup(() => clearInterval(id));\r\n * }, { priority: 'high' });\r\n *\r\n * // Destroy manually if manualCleanup = true\r\n * ref.destroy();\r\n * ```\r\n */\r\nexport function concurrentEffect(effectFn: (onCleanup: EffectCleanupRegisterFn) => void, options?: ConcurrentEffectOptions): EffectRef {\r\n  if (NG_DEV_MODE) {\r\n    assertNotInReactiveContext(concurrentEffect);\r\n    if (Integrator.instance === null) {\r\n      throw new Error('concurrentEffect(): ' + INTEGRATION_NOT_PROVIDED_MESSAGE);\r\n    }\r\n    if (Integrator.instance.isServer) {\r\n      throw new Error('concurrentEffect(): ' + SERVER_SIDE_MESSAGE);\r\n    }\r\n    if (Integrator.instance.uncompleted) {\r\n      throw new Error('concurrentEffect(): ' + INTEGRATION_NOT_COMPLETED_MESSAGE)\r\n    }\r\n  }\r\n\r\n  const priorityLevel = priorityNameToNumber(options?.priority ?? 'normal');\r\n  const manualCleanup = options?.manualCleanup ?? false;\r\n  const allowSignalWrites = options?.allowSignalWrites ?? false\r\n  let destroyRef = options?.destroyRef ?? null;\r\n\r\n  if (NG_DEV_MODE && !manualCleanup && !destroyRef) {\r\n    assertInInjectionContext(concurrentEffect);\r\n  }\r\n\r\n  if (!manualCleanup && !destroyRef) {\r\n    destroyRef = inject(DestroyRef);\r\n  }\r\n\r\n  const effectRef = new EffectRefImpl(effectFn, priorityLevel, allowSignalWrites);\r\n\r\n  if (!manualCleanup) {\r\n    (destroyRef ??= inject(DestroyRef)).onDestroy(() => effectRef.destroy())\r\n\r\n  }\r\n\r\n  return effectRef;\r\n}\r\n","/*\r\n * Public API Surface of core\r\n */\r\n\r\nexport * from './src/core';\r\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './public-api';\n"],"names":["ɵglobal"],"mappings":"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"}